vector -- 顺序表
--类似于数组

原型：template<class T, class Alloc = allocator<T>> class vector;
allocator:空间配置器(内存池) -- 本质也是从堆中而来 -- 缺省

类模板
需要给其一个类型
vector<int> v1(n, x)插入n个x数据

只提供了尾插、尾删、和指定位置插入、删除
尾插：push_back(const T& val);
//传引用 -- 使用内置类型无所谓，但是如果是自定义类型就非常好用了

遍历：1、利用下标+[]   -- at也可以使用
2、迭代器：
vector<int>::iterator it ;


max_size() -- 此时就不是整形的最大值了，10亿多 42亿九千万 / int类型(4)

扩容方案：
resize();
reverse();
vs下的STL差不多就是1.5倍去扩容的
g++下的STL基本按照2倍去扩容的
基本和string类似

swap也是为了防止外面发生深拷贝 -- 

vector没有提供find
<algorithm>//算法头文件
reverse就是在这个里面实现的
--通用 在外面统一实现
最通用的：传入迭代器（迭代器区间基本均是左闭右开）
函数模板：template<typename InputIterator, class T>
返回一个迭代器find(迭代器区间， 找的数据)
--不存在就返回end

insert给的就是迭代器，传入也就是迭代器
insert(迭代器, val)，在此迭代器前面检查如val

erases删除某个迭代器所在的数据 、删除某个迭代器区间：
必须要检查 -- 不存在的值就会报错

也可以比大小

但是vector不支持重载流插入 -- <<、>>


想要排序如何去排序呢？以前C使用的是qsort
同样的，在STL算法里，sort -- 底层就是一个快排
传迭代器区间即可，只不过也是一个函数模板

迭代器 -- 更好和算法进行配合 -- 算法就可以写为泛型，适合于多种容器提供使用
默认升序。

第二个就是仿函数 -- （stackqueue章节去讲）
类模板
less<int> ls; -- 默认就是升序（算法头文件） <
greater<int> gt;降序（在function的头文件）
sort(v.begin(), v.end(), ls);
sort(v.begin(), v.end(), gt);//平时就可以传其

当然，也可以这么取用：
sort(v.begin(), v.end(), greater<int>());--直接传匿名对象即可
先会用即可
泛型编程

string也能排 -- 按照ASCII码值去比的。

注意vector<char> -- 无法替代string 因为有不可代替的接口和函数
但是vector就可以作为一个存储string类对象的一个顺序表
插入一个字符串就是一个string的隐式类型转化

但是此时拷贝的对象使用范围for的时候，就传const引用了，不这样做就会拷贝构造，然后发生深拷贝代价很大哦~




只出现一次的数字：异或 -- 经典解法：


DFS深度优先遍历：
循环控制递归 字母组合
首先数字映射 -- 字符串数组





vector的模拟实现：
pg版可读性比较差

使用stl30.tar.--进行学习源代码

学习框架 -- 不可一行行的进行查看

三个成员：
迭代器  --- vector内部是连续的空间 -- 迭代器使用的就是原生的指针

首先模板--template
定义原生指针为迭代器iterator
三个成员：
_start;最开始的数据的指针            begin()
_finish;最后的数据下一个的指针     end()
_end_of_storage;容量的最后一个指针

构造：
无参就全部初始化nullptr

析构：
加了一个内存池 -- 空间配置池 -- （先不使用）
直接delete即可

尾插
push_back(const T& x) // 利用const -- 因为这样可以适合隐式类型转化 -- 产生临时变量 -- const常性质
{}
使用引用 -- 防止自定义进行深拷贝代价太大了

capacity、size--通过地址指针计算即可

reserve -- 扩容即可


operator[]  



迭代器实现--
原生指针

有了迭代器 -- 范围for （实际就是底层进行了一个傻瓜的替换  -- 即必须要对应的begin和end，变一个字母就不得行）

pop_back尾删

insert(iterator pos, const T& x)指针位置插入
挪动数据
但是注意，一旦里面发生扩容，原本数据会被拷贝到新的空间，旧空间释放掉，但是形参里面的pos还是指向的旧空间哦~4
--迭代器的野指针 -- pos失效 -- 迭代器失效
解决方法：扩容的时候前记录步长，然后更新即可。

但是注意在外部的的迭代器，如果在扩容之后，在对这个迭代器进行操作 -- 就会出现问题。 原因就是扩容之后，外部就失效了，里面更新，外部没有 -- 
迭代器失效：
所以在对于外部的更新 -- 在p位置插入数据后，就不再使用了  但是可以用引用传入：但是库里面没有实现这样的引用 -- 因为有时候会出现问题 ： 比如：在传入begin的时候，就会出错 -- 返回的是拷贝 -- 具有const   -- 再去修改其他的就会有一大串问题，所以这里就遵循不引用传入了。



erase(iterator pos)删除pos位置的值

注意，只要存在挪动空间，就需要注意迭代器失效的问题了 比如erase的缩容了（以时间换空间）


原则：insert和erase后，原本的迭代器变量就不再使用了 -- 有可能失效  野指针 --  迭代器失效

但是在遍历删除的时候 -- 原本的删除不行 --  更新一下迭代器就好了
erase返回下一个位置的迭代器
VS下和Linux下可能会不一样：STL只是一个规范-->不同的平台下面实现是不同的。
VS-PJ版本  g++
VS下对迭代器会进行强制检查，如果原本指向的数据被清除了，下次在对此处指向（存在数据，不是野指针），但是会检查报错
Linux下：12345没有问题（删去偶数，不正确使用） 1234 段错误  122345 1235
	-- 数据排列的偶然性（最后一个不是偶数，没有连续的偶数）


默认拷贝构造 -- 1.内置类型值拷贝 浅拷贝 自定义类型 拷贝构造
传统写法：
new 给size或者capacity都可以


现代写法：
先初始化，调用reserve开辟size() 
然后使用范围for，复用push_back()

先写一个迭代器区间构造：
类模板里面可以套着函数模板
template <class InputIterator>  -- 为了让各种类型的迭代器均可使用
vector(first, last);
首先初始化，然后遍历插入即可。

然后现代写法就可以进行复用了--最后交换

赋值重载
vector& operator=
传参直接不传引用 这样传参就可以引用拷贝构造，形参已经帮你打了工了，然后交换即可

注意，其实内置类型，在C++内也是有构造函数的    int() -> 给的就是0 指针不一定（但是模板支持 即
）template<class T>
	const T& val = T()   -- 匿名对象

但是注意在构造函数vector(size_t i, const T& val = T())的使用中，可能存在int,int就会报错的问题，因为编译器在类型匹配的时候，会找最匹配的那一个。int int 不和其完美匹配，因为还有一层转化， 所以会和迭代器区间构造最匹配。
--解决方案
10u, 1。
1. size_t 改为int 也是可以 -- 但是官方库里面给的就是size_t  -- > 可以给个重载就可以解决了


resize(size_t n, const T& val = T())
1.n > capacity 扩容加初始化
2.n > size, n <= capacity 初始化
3.n <= size  截断  删除数据  


深层次拷贝--  拷贝构造、扩容  -- memcpy
二维数组的时候 ---嵌套vector<int>
vector<vector<int>>
--是不是析构的错呢？
验证 void
--实际上是拷贝的原因：
拷贝是用了深拷贝
但是是有两层vector：
	原本的拷贝构造中：外层vector确实拷贝了一份，但是内部的数据（以前一般是内置类型，现在是一个自定义类型），值拷贝，然后这些就都会被析构。-- 析构同一份空间 自然会出错

-- 传统写法：不能使用memcpy--内部就是浅拷贝        -- 内置类型可以，自定义类型就不行
解法：利用for一个一个拷贝  -- > 调用赋值-- >这样第二层也就是深拷贝了
--现代写法：push_back() - > reserve()的问题   -- 同样是memcpy的问题
--浅拷贝都是释放同一空间出来的

