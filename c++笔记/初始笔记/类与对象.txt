c语言是面向过程的，关注的过程。求解问题的步骤，通过函数调用逐步解决问题。
c++是基于面向对象的，关注的是对象，将一件事情差分成不同的对象，靠对象之间相互作用。

1.struct 结构体
c++将struct升级成了类(同时兼容c语法)   里面可以定义成员变量 成员函数
定义的时候struct就是一个类型，使用成员变量和成员函数就是 类名.成员变量  类名.成员函数();
但是c++更喜欢用class


2.class定义类

访问限定符：public公开、protected保护、private私有
class成员默认访问权限是private，struct默认是public(因为要兼容c)
为了将成员修饰成公有的，可以使用public:直到遇到末尾或者下一个访问限定符为止。
public类外可以访问，protected和private类外不能访问（后面继承才会出现区别）


类的两种定义方式：
1.声明和定义全部放在类体重，注意，成员函数如果在类中定义，编译器可能会当做*内联函数处理。
2.声明放在.h文件中，类的定义放在.cpp文件中  声明类的结构在.h  定义成员函数就在.cpp 注意在.cpp定义成员函数时，需要加上类域 即在函数名前加上类名::即可，就可以访问该类的结构     *但是此结构就不能使用内联   因为这样在编译时不会进入符号表，链接的时候就会找找不到
 分离的意义：方便查看和检查代码
注意域的访问遵循就近原则，现在本{}局部域找，找不到就去对应附加的域(类域class，命名域namespace)
	注意：域应该只是限制访问权限，真正影响生命周期的是：（函数调用建立栈帧）栈  （直到free）堆 （静态变量，程序结束销毁） 静态区  常量区   ----->即所储存的区域
		变量的生命和定义就要区分是否给变量开空间。如果是全局变量的话，直接int a;就是定义了，因为会默认给全局变量0，但是如果在类域中这样写的话，就是声明，因为这样并没有实例化，没有此类的一个成员。只有定义其类的成员，即实例化后才是定义，就会开空间。
		
3.类的实例化
可以把类比作设计图       实例化对象即就是修房子。  图纸自然没有空间。房子才有空间。
但是sizeof(类名); 可以查看其空间大小，因为也遵循内存对齐这个概念。也可以类比于利用图纸来估计大小。
注意：	在头文件声明一个全局变量 如果在两个cpp源文件声明的话会出现重复链接。解决方法：extern（声明，在对应文件内定义） static(只在当前文件可见，每个文件都是各自的，不用放入符号表。  全局变量就是公共的，所有文件可见)
那么如何计算类的大小？
首先明白对象的储存设计：实例化的每一个A（类）对象成员变量都是独立空间，是不同变量的 但是每个A对象吗，调用的成员函数都是同一个。
对象里面只存变量的大小，函数就放在公共代码区。这样，对应的变量就去对应的空间找，函数就是在编译链接的时候就根据函数名去公共代码区找到函数的地址。 call 函数地址。
 所以，在空指针的情况下  A* ptr = nullptr;  ptr->func();   如果类内定义的有此成员函数的话，那么就会正常运行，没有发生解引用

空类和仅有成员函数的类大小均为1（不是0的原因是：进行占位，标识对象存在）
遵循c语言里面的struct结构体的内存对齐


4.this指针
非静态函数里规定了第一个参数为隐藏参数this来指向本对象里面的变量 因为成员函数处于公共区域，需要指向本对象内存的变量。类名* const this
但是编译器规定，不能修改this指针，即不能参数列表里显示this （原因就是const 右定向，this不能接收其他的了）
但是成员函数内部可以使用this指针
所以，如果是引用上面的那个空指针去访问成员函数的话，如果此成员函数中存在成员变量，成员变量前默认加上this-> 会使用空指针，就会崩溃了。（编译报错-》语法错误）

this指针正常情况下存在栈区域，---属于形参
但是有时候不是，vs优化会放在寄存器上exc。比如频繁的调用this指针



****
5.类的6个默认成员函数   用户没有显示实现，编译器会自动生成
 *初始化和清理 ：构造函数、析构函数   *拷贝赋值：拷贝构造、赋值重载   取地址重载：....（这个很少自己实现）


    1.构造函数：
如果还是按照c语言那样初始化，但是有时候会忘记初始化
所以能不能在实例化类的时候一定初始化呢？---构造函数  -->作用就是来初始化的。

特性：1.是一个特殊的成员函数 不是开空间创造对象，而是用于初始化的。（构造是由栈帧实现的）
2.函数名和类名一致 3.无返回值，不用写void 4.对象实例化时自动调用对应的构造函数 5.同样可以重载
类名()
{
}	
所以全缺省函数就会非常好用，但是此时的无参构造器就不能存在，因为调用存在歧义。（缺省就需要从右到左，传参时从左到右）
如果用户没有显示定义构造函数，那么编译器默认生成一个无参构造函数。如果用户显示定义了，那么就不会自动生成了。
注意：C++类型分类：内置类型(基本类型)：int/char/double/指针....  自定义类型：struct/class
*但是默认生成的构造函数，对内置类型成员不做处理，对自定义类型的成员会去调用其默认构造函数。(C++早期设计的缺陷，本来内置类型也一并处理，就更简化了) c++11打了一个补丁：即可以在类内，给变量赋值一个初始值，但不是初始化，而是给缺省值。因为在这个里面时声明

默认构造函数有三类：
1、我们不写，编译器自动生成的那个
2、我们自己写的，全缺省构造函数
3、我们写自己写的，无参构造函数
特点：定义类对象不传参数均叫默认构造函数  默认构造函数只能存在一个（可以同时存在，符合语法，但是调用会混淆（存在歧义/二义性））
注意，补丁是属于默认构造函数调用的。

总结：
	1.一般的类都不会让编译器生成构造函数，都会自己写。显示写一个全缺省，非常好用。
	2.特殊情况下，会使用默认生成构造函数（由其特性，特殊情况就是指不存在内置类型，或者只有几个（很少）的内置类型）

    2.析构函数：（和构造函数作用相反，但是注意，不是完成对象的销毁--这个是编译器完成的）
对象销毁（对象的生命周期结束）时，会自动调用析构函数，完成对象中资源的清理。
在类似于构造函数前加~ --->说明和构造函数功能和析构函数功能相反（按位取反）
~类名()
{
    //打扫卫生	（清理需要我们手动清理的）
}
注意：1.无参数，无返回值 2.无法重载（没有参数）3.没有显示写，系统会自动生成了默认的析构函数
什么时候析构函数有用呢？--比如栈需要清理申请的堆内存 可以在析构函数中写free
那么，默认生成的析构函数有什么用呢？
	跟构造函数类似，内置类型不处理，（环境复杂（指针不一定都是malloc一个的，还有其它的），不好处理）自定义类型调用它的默认析构。
	适用于全是自定义类型时（比如用栈实现队列那里）--（比如实现数据结构的时候）
出了类对象作用域，自动调用。
	（查找某处语法是否正确，查可信的书，查官方文档）

（注意，java的垃圾回收器是针对的new出来的对象，而不是这里和~类似的功能哦）

    3.拷贝构造函数：
类名 d1; 类名 d2 = d1/类名 d2(d1);
是一个特殊的成员函数。是一个构造函数的一个重载形式。
显示构造：参数只有一个，并且必须是类类型对象的引用，使用传值调用会报错，发生无穷递归。
    传值传参为什么不行呢？
	首先区分传给普通函数一个类的传值传参（这样发生拷贝，赋给形参，调用时会调用拷贝构造）和传引用传参
	那么在给该类传值传参时（参数是类对象），就会调用其拷贝构造，然后此拷贝构造函数的参数又是一个拷贝构造....无穷无尽。问题就是出现在参数上。
	解决方案：使用传引用传参即可。（或者指针--但是这个就不是拷贝构造了，拷贝构造的参数必须是其类的类型）
但是注意引用前面加上const使其不能被改变，防止出现问题----编译不会报错，但是一运行就出现问题了，把想要拷贝的数据修改了
类名(const 类名& 变量名)
{//赋值}

类似场景就是需要拷贝，不改变原来类对象中的值的时候。
那么编译器默认生成的做什么事情呢？
	内置类型，按照字节方式直接拷贝，而自定义类型调用其的拷贝构造完成拷贝的。
但是有时候有些拷贝需要我们自己写
*--深浅拷贝问题。（存在让多个指针指向了同一个空间，然后产生很多问题a、一个对象修改会影响另一个对象，会析构两次，导致崩溃）比如栈和链表...

前二者总结：
     构造：1.大部分的类需要自己写构造函数。2.一般只有像Myqueue这样的类不需要显示写构造函数（两个栈实现一个队列）
	3.每个类最好都要提供默认构造函数（不用传参数）。（构造函数要频繁的调用。放在类里作为inline）
     析构：4.一些类需要显示写析构函数（stack，Queue...）5.一些类不需要显示写析构函数。a.Date这样的类，没有资源可以清理b.比如MyQueue也可以不写，默认生成的就可以（和构造函数类似，默认的会自动调用自定义类型的析构函数）
	6.由于函数和变量均是填入栈帧的，（栈和栈帧里面的对象）所以均符合后进先出，也是后定义先销毁/析构（注意析构不是销毁哦~）		栈帧是由ebp、esp两个寄存器控制的
*初始化和销毁：全局和静态局部变量均存在静态区，全局会在函数没有创建出来就进行初始化。在函数栈帧里的生命周期随着函数而存亡。除此静态区和栈保持一致，先进先初始化，后进先析构然后销毁

	
    4.赋值重载&运算符重载
没有显示写，编译器会默认生成一个赋值重载（参考拷贝构造）
	内置类型值拷贝，自定义类型调用其的赋值重载
那么，哪些情况下需要自己写呢？（和拷贝构造一致）
	比如栈这样的类。
不需要自己写的比如用栈实现队列，和普通的一般的类（比如Date）。（躺赢的，直接调用里面自定义自己写的赋值重载即可）

前二者总结：（没有总结完，有一些涉及深浅拷贝-->需要自己写的）
	      拷贝：7.引用实际就是为自定义类型准备的。传值传参需要调用拷贝构造-->构造对象  （但是注意传值和传相同类型的引用，可以构成重载，但是调用会构成歧义）*结论：传对象：传引用返回比传对象返回效率更高（需要注意生命周期，即出了此函数就销毁的就存在问题）
	1.一些类需要显示写拷贝和赋值（Stack、Queue）
                2.一些类不需要显示写拷贝和赋值。（a、比如Date这样的类，默认生成就会完成值拷贝/浅拷贝）
				     （b、比如MyQueue这样的类，默认生成就会调用他自定义类型成员Stack的拷贝和赋值）


内置类型可以直接使用运算符运算，编译器知道要如何运算，自定义类型不知道哦~
想支持，自己实现*运算符重载即可。
增强了可读性，运算符重载具有特殊函数名的函数
函数原型：返回值类型 operator操作符(参数列表（const 引用传参）){//实现逻辑}（传类对象就要想到传引用）
	返回是逻辑关系就是bool，返回是值返回对应的值
可以显示写，但是运算符重载就没意义了。
但是在外面实现 有时候如果是私有对象就存在问题。
处理方式：1.提供私有变量一个外出接口。2.放到类里面（但是此时注意this指针，第一个参数就是this指向的对象，第二个就是第二个对象，但是不能显示这样写）比如 d1 < d2   --->  d1.operator(d2);

 
日期类举例：Date
Date& operator=(const Date& d)
{//判断是否是同一个}  存在 d1 = d2这样赋值的

//任何一个类只需要写一个> == 或者 < == 的重载，剩下的比较运算符的重载复用即可
+ 复用 +=  （反过来复用会多次使用拷贝构造，效率会低下）
一个类可以重载哪些运算符？-->哪些运算符对这个类有意义。
代码要足够细腻 考虑多方面的条件
针对++的前置和后置，
operator++()默认是前置，operator++(int)是后置   --  进行区分

那么，给类对象赋给初始值通过键盘输入  内置类型可以直接使用  -- >库里面已经写好了运算符重载 自动识别类型--函数重载（流插入流提取）
cout是ostream类型的一个对象

运算符重载：让自定义类型对象可以使用运算符，转换成调用这个重载函数
函数重载：支持函数名相同的函数同时存在。
注意上述两者没有关系

那么想让自己的自定义类型使用cout或者cin就可以使用运算符重载
ostream& operator<<()..这样是不能的，库里面的函数，塞不进去。
那么就在自己类里重载
void operator<<(Date* const this(隐藏), ostream& out)
{
    out<<_year <<...
}
但是只是上面的，会报错  原因就是顺序问题：这样调用 d1.operator<<(cout)就可以 但是cout << d1这个就不行了 d1 << cout到是可以，但是表达就不明了。
要想解决的话，就不能是成员函数，因为this已经固定了，必须是左操作数
所以可以：全局函数即可。但是这样私有成员就不好访问了
*所以出现了友元函数 -- 类内任意位置，这样可以使用其类中的私有对象。一般声明在类第一行    friend 函数声明
void operator<<(ostream& out , const Date& d)
{
   
}
但是注意<<的原本操作，支持连续插入 << <<  那么返回值返回 ostream&即可




运算符重载规定：
1.不能链接C++没有的运算符
2.必须要有一个类类型参数
3.不能重载的运算符：.*  ::  sizeof  ?:   .

	
	5.取地址运算符重载：
	类*/const 类* operator..
	不写编译器会默认生成 -- 默认成员函数  自动生成就够用了（一般不需要我们自己写 -- 各种场景下基本够用）特殊场景：不想别取到这个类型对象的地址 

6.const 类对象
假设存在 const Date d2();  那么不能使用d2的成员函数  因为存在this指针即成员函数默认参数 Date* const this
一般的没有const        &d1 -- Date*    传  this
const  &d2 -- const Date*  传 this   原本要求指向的对象本身不能改变，但是传给this指针后就可以改变了，权限的放大，不可以。
那么如何修改隐藏的this指针呢？不能修改--编译器不认
所以就直接在函数名()后加上const即可  即就修饰  const Date* const this指针了。
注意权限的缩小和权限的平移均可。

*注意 权限的放大和缩小针对于 指针和引用
所以，只要本身不会改变，就需要在后面加上const 来表示可以使用const修饰类对象。不能修改其中的内容
自然，加上const同样可以实现函数重载





----针对于构造函数有很多地方需要优化： -- 初始化列表：
因为默认构造会默认调用自定义类型的默认构造，但是当想给自定义类型在定义时赋值的时候，就会出现问题。
此时就有初始化列表：
以:开始，;分隔，去初始化成员，没有在函数体内进行初始化。那么此时就可以给自定义类型赋值不用调用默认构造函数，而是使用有参的构造函数了。
三类成员*必须使用初始化列表进行初始化：自定义类型成员（没有提供默认构造）、const成员也必须在初始化列表进行初始化（因为const只有一次机会初始化，所以必须定义的时候同时初始化）、类似的引用成员同理。
*
:成员变量(给的值)
,...                           这样可以显示的进行调用自定义类型的构造函数
*
() 类似于 成员变量 = ... 
自定义类型就是其定义的样子。
当然，有默认构造函数的自定义类型就可以不需要初始化列表。


结论：自定义类型的成员推荐使用初始化列表进行初始化。
初始化列表可以认为是成员变量定义的地方。//不管写不写，均会生成，不写就默认给随机值和调用自定义类型的默认构造，写了就会默认用你自己写的。
内置类型也推荐使用初始化列表。

实际上c++11补丁给的内置类型缺省值，就是给的初始化列表进行定义初始化。但是当初始化列表里进行显示给那么缺省值就没有用了。


但是有些场景也还是要在函数体内进行初始化：
比如内置类型：int* _a的时候，如果在初始化列表进行初始化，使用malloc的时候，就不能处理返回NULL的情况了，还不如在函数体内进行。
--混合搭配食用更佳。

*但是注意有一个坑：初始化列表初始化定义顺序和类内声明顺序有关，和其列表的顺序无关。 -- 小心随机值哦~

类对象定义在其对应函数内定义，类成员声明其类中，类对象的成员定义在构造函数的初始化列表中定义初始化。






注意区分下面两者区别：
Date a(2022); --直接调用构造    Date a2 = 2022; -- 隐式类型转换：构造 + 拷贝构造 + 优化 ->直接调用构造
int 2022 转换为Date的临时变量 -- 注意具有常性 和引用那里的临时变量类似
用处在 -- string类进行    string s1 = "hello";       传自定义类型的时候可以直接传字符串值，进行隐式类型转换
 
explicit关键字在构造函数前就表示此类不能被隐式类型转换，即上面的Date a2 = 2022;
自定义类型传参尽量用引用，引用尽量前面加const



匿名对象：
当只包含类名，不包含对象名定义的类对象，那么其的生命周期只有这一行。
比如：Date(2000);
适用场景：只想调用这一次这个对象的情况。比如执行调用其类中的一个函数 类名().成员函数即可。

注意优化特性：
比如以类对象作为参数的函数，此时传一个匿名对象，本来会先自己构造，发生拷贝构造。但是会进行优化，变成直接构造。
结论：连续一个表达式步骤中，连续构造一般都会优化成一个构造。--合二为一
（注意只能传值返回自定义类型的，即传拷贝返回，不会传原本的参数。）
但是当：w为一个自定义类型
w f()			w w1 = f();  -- 本来是1次构造，两次拷贝构造。   但是会优化成一次拷贝，因为连续拷贝。但是此时不
{			应该用内部ret，因为常规来说ret出了作用域生命周期就没有了。那么，此时该如何优化的呢？
    w ret;			本来针对于此，会产生一个临时对象，如果大小为4 - 8byte放在寄存器，大了就会向上压入上一层栈
    return ret;		帧即可。所以，此时进行优化，就应该就是直接这个栈帧的对象替换调上一栈帧对应的对象。此优化是
}			debug的优化，release的优化更加猛。（Linux下优化的更猛，debug优化就会很猛）



static成员：
静态成员 
普通成员变量可以在初始化列表进行初始化，但是不能定义初始化静态，所以此时给缺省值也不行。

所以，静态成员必须在类外进行初始化：
类型 类::静态成员名 = 0;即可

静态成员属于此类，该类的所有对象均可使用。

函数前也可以加static -- 静态成员函数 -- 没有this指针。所以此时该函数里面不能访问成员变量，只能访问静态变量。静态全局变量放在静态区，生命周期是整个程序。

静态函数就可以不用对象去调用，可以通过指定类域去调用。


体现了封装，不让别人随意去修改。




定义一个只能在栈内定义的类：
只能定义在栈上，那么其他区域比如静态区，堆区就不能，那我们不妨都先限制创建，将构造函数限制在private内，然后利用静态函数构造一个堆区的对象即可。-- 外面使用拷贝构造函数即可。
注意，静态成员函数不可以访问成员函数，成员函数可以访问静态成员函数。




友元：
friend
友元函数：
比如用运算符重载流插入的时候，就要重载成全局，成员的话默认this指针就是第一个不是流。
注意：不能用const修饰，可以是多个类的友元函数。不是类的成员函数。
友元类：
此时一个类就可以访问声明友元的类里的私有保护成员。

友元关系是单向的



内部类：（C++很少使用，Java用的很多）
一个类定义在另一个类的内部，此时默认此类就是外面类的友元类
注意：外部类和内部类大小不冲突，除非成员含有其类成员。 -- 内部类：1.受外部类类域限制，外面想调用必须是公有部分并且加上访问限定符。2.内部类天生就是外部类的友元。






面向对象三大特性：封装、继承、多态（面向对象不止三个特性，只是最出名的）
封装：本质上是一种管理。不想让你访问的使用private/protected，开放使用的就用public。

针对于C语言的缺陷：
C++增加了STL标准模板库，比如栈C语言需要自己实现，C++里面可以直接调用。
即使C语言写好了，但是必须清楚实现栈的代码实现，--自由的走，没有封装 ，而且必须要谨慎内存泄漏。C++ ->类 ->构造函数、析构函数  -- 自动调用，这样就不会忘记    -- 存在深浅拷贝  -- 拷贝构造函数         为了能方便使用像内置类型一样 -- 运算符重载。
C++设计的类是针对于C语言的缺陷进行设计的。并且编译器做了更多的事情。



C++命名规范
公司的要求
单词和单词之间首字母大写间隔--驼峰法 GetYear
单词全部小写，单词之间_分割		get_year

驼峰法：
1.函数名 类名 首字母大写
2.变量首字母小写，后面首字母大写
3.成员变量，首单词前面加_ 首字母小写




