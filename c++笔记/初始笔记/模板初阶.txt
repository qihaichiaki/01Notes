模板初阶
提出概念：泛型编程（C语言是具体类型去编程）

针对于不同类型的交换数据，需要进行函数重载
-- 能不能进行一个泛型编程--不重复的干类似的事情、代码复用（仅仅只是数据类型） -- 模板 --（古人的智慧：活字印刷术）

	函数
模板
	类

函数模板
目前typename和class一致，typename可以换成class
语法：template<typename T(名字随便起,一般是首字母大写),...> //模板参数 (模板类型)-- 类似函数参数(参数对象)
T代表的是一个模板类型（虚拟类型）
此时交换函数：
template<typename T>               --没有; 模板   类型名字
void Swap(T& left, T& right)
{//...}

但是注意，不同类型调用此模板函数用的函数均不一样。
能用 -- 函数模板的实例化：
模板参数推演     函数模板     推演参数实例化（具体参数）
	（替换类型过程） 生成对应的函数

好处：只写一个函数（把我们干的事情交给编译器去做）
坏处：编译的过程更加复杂了


（auto 自动推导类型  -- 意义为了省，写起更加方便）


但是在std命名空间内也存在一个交换函数 -- swap();   
T Add(const T& left, const T& right)
{
	return left + right;
}
注意，模板不可以隐式类型转换。（函数里面形参发生隐式类型实参传参的时候），但是模板就会推演实例化报错--不知道要哪个类型。
处理方式：1.不干预推演，自己转类类型。（隐式实例化）2.显示实例化 Add<int>(...) 3.给两个模板类型

显示实例化用在无法自动推演的时候。
注意，优先看是否实现参数对应的函数，然后才看模板函数。
	--原则：有现成就行、没有就自己做   ---   模板函数同样符合重载相似的效果


类模板
typedef不属于泛型编程  -- 还是针对具体的类型  比如想要两种类型的栈

template<typename T>
class Stack
{
	...	
	T* _a
	...
}
此时就可以解决
但是此时注意单单是 Stack t;就不行了，不可以自动推导    Stack<int> t;  Stack<char> t2;   -->用了一个类模板，但是是不同的类型哦。


-- 使用类模板实现简单的栈
需要注意的是：模板不支持分离编译 声明放在.h，定义在.cpp    实现放在一起   
但是支持在同一个文件可以，并且指定类域和进行模板类型声明。
模板实现的.h文件  可以改为hpp  -- 一般模板就可以使用这样的

模板参数也可以使用缺省参数  但是全缺省的话还是要把<>加上









