补充内容：
找实习 -- 能够做简历 -- 至少有一个项目
（暑期）实习 -- 3 - 5 （大三、研二）最晚时间点	找到了就可以去
秋招 -- 9 - 11月	大四/研二

笔试强训 -- 笔试


六大组件 -- 容器、适配器、迭代器

此类就是适配器
stack、queue
结构非常简单 - 不存在迭代器（为了保持分别不同的特性）

size
empty
top
push
pop
swap


栈刷题：
1.最小栈：
o1的获取最小元素
添加辅助栈 -- 每次添加值是最小值就插入此辅助栈，pop出最小元素同时pop辅助栈，让辅助栈最后元素一直存储当前栈内数据内数据的最小值。

加码：如果有大量重复数据插入--> 10w个	（）
计数--
	minst可以存入一个结构体（比栈底大就不更新，小更新，相等就++计数）

2.栈的压入、弹出序列：
利用栈去模拟这个过程：根据压入序列和弹出序列进行连续压入和连续弹出
不和弹出序列匹配就入，匹配后就出 

3.逆波兰表达式求解：（后缀表达式（运算符在后面）） 中缀表达式（1 + 2 * 3  -- 计算机不能算，优先级顺序）
					会转化为：1 2 3 * +  （会把运算符的优先级排出来）

后缀如何运算：（操作数的顺序的不变 操作符优先级排出来）
	1.操作数入栈
	2.遇到操作符：操作数就去连续两个栈顶数据运算，运算结果入栈


中缀转后缀：
	调整运算符的优先级：
	1 + 2 * 3：  1 2 3 + *
	1 + 2 - 3：   1 2 + 3 - 
	栈：
	1.操作数输出：
	2.操作符先入栈：确定优先级  
	比栈顶运算符优先级高 入栈 
	相等或者低输出栈顶的运算符(然后连续比)

	1 + 2 * 3 / 4 + 5 - 6:
	1 2 3 * 4 / + 5  + 6 - 
	
	1 + （2 + 3）* 4 - 5：（遇到括号将其运算符级别提高，可以利用flag进行提升）
	1 2 3
	+ +

	1 2 3 + 4 
	+ *

	1 2 3 + 4 * + 5 -





栈和队列的模拟实现：
之前的容器有空间配置器（内存池）  -- 但是官方库没有传，传的是一种容器
适配器：是一种设计模式。
写代码过程中有很多经验、方法。总结了很多种。适配器模式就是其中一种。
栈和队列就可以使用适配器来搞。

-- 转换 -- 得到自己想要的东西。例子：比如电源插头，也叫电源适配器。

class Containers = deque<T>
(容器转化器)
容器适配器  -- 利用其他容器转化为我需要的

封装一下已有的类进行利用，不用重复太多算法过程：

vector<T> _con;
// 只实现一些：push、pop、top（T&）、empty、size
全部都可以直接复用。
封装了一下vector<T>而已。

那么现在这个栈是不是一个适配器呢？不是。例子：电影充电接口。
此时底层写死了。--vector实现的

增加一个Container模板参数 表示一个容器。有显示传入即可。
编写时注意需要通用的方法。
（好比充电器的另一头接的电源是哪里的，只要能给我充电就行）
上层角度看都是一样的，底层的差别却很不一样。

官方传入了一个缺省模板（容器）双端队列：
deque    --  查看其实现功能：vector、list的合体  -- 同样也是看起来很牛皮 -- 外强中干
可以选择适配器默认传此。

队列同样如此，但是vector不支持（没有pop_front)  -- >提供还不好，本身此容器执行此功能效率低下。	




（了解）
简单介绍一下deque：双端开口的队列。
底层实现：
vector  --  [                                  ] 数组 （高效尾插尾删、随机访问）
list -- [] - [] - [] - [] - NULL 链表 （头插头删、不支持随机访问）
deque  -- [                  ] 
	[                  ] 
                [                  ]....   -- 开空间 小数组buffer 
【                             】 中央控制的指针数组（一开始开在中间）   -- 逻辑上进行连续 头插往左扩展  尾插向右扩展
方括号重载也是：利用公式达到快速访问的效果。
优势：啥都能干、头尾插入删除、随机访问
设计缺陷：[] vector是直接通过指针访问的，但是此时经过计算的。即计算稍显复杂。大量使用，性能下降。（相比vector）
	中间插入删除效率不高。
	迭代器的实现复杂。（四个指针：cur 缓冲区的开始 last缓冲区的结束 frist  Node指针数组） 当一个buffer跑完，node就会对应找到下一个地方的buffer -- > ....... cur 和 last指向buffer的开始和结束。
总结：--不好用。
结论：头尾的插入删除 -- 相比vector、list而言。很适合去做stack、queue的默认适配容器。
中间插入删除多：list
随机访问多：vector
  
	
	

优先级队列：priority 优先事件
priority_queue  -- 容器适配器
使用的适配器容器是 class Container = vector<T>
还有一个模板参数是仿函数

数据的优先级顺序是？（看场景、环境）  -- > 测试：默认是大的优先级高 大堆
不存在迭代器，边取边走。
底层是一个堆。

如果想控制小的优先级高呢？（默认大堆）
priority_queue<int, vector<int>, greater<int>> pq;  // 此时就可以控制成一个小堆。

								   >
								greater	       < 
模拟实现：           适配器                                              仿函数                         默认less->大堆  less是小于的比较 在bool中进行运用
class T                class Container = vecter<T>            class Compare = std::less<T>  	模板的虚拟类型
仿函数我们是要切换
public:
// 默认大堆  -- 现在这里是写死的大堆 但是排序的时候不能直接把源代码改。所以需要一个开关  -- 仿函数
	构造支持迭代器区间构造
	temp <class InputIterator>
	...
	{
		while (frist != last)
		{
			// 插入
		}
		// 利用向下调整建堆
		
	}
	void adjust_up(size_t child) // lgn
	{
		// 	
	}
	push(const T& x)
	{
		_con.push_back(x);
		adjust_up(); // 向上调整	n*logn
	}

	void adjust_down(size_t parent) // logn
	{
		
	}

	pop()
	{
		//头尾交换，删尾 向下调整
		adjust_down();  //向下调整   longn
	}

	const top()
	{
		// 堆顶
	}

	empty
	size	

private:
Container _con;


仿函数  ：：替代函数指针（尽可能的不要去用）
-- 类、重载()  ()同样是一个运算符 (表达式) 函数(参数)

让类对象像函数一样去使用。本质上调用了()重载

namespace 
{
	struct less
	{
		bool operator()(const int& l , const int& r)
		{
			return l < r;	
		}	
	};
}

这里仿函数传入的是类型，sort是一个函数模板，所以传入的是一个对象。（必须是对象，可以查看模板是如何写的）

优先级队列也不能传对象	
直接传对象的化，如果和仿函数模板参数冲突的话，就会出现问题。

const引用会延长匿名对象的生命周期


经典的容器适配器：stack、queue、priority_queue

STL六大组件：
	容器、仿函数、算法、迭代器（封装--读和写的方式提供  1.降低了学习的成本 2.不关心内部底层实现细节）、空间配置器、配接器（适配器）

泛型--模板（本质）
迭代器：不暴露底层细节的情况下，提供统一的方式去访问容器，屏蔽底层实现，体现了封装的价值和力量。



