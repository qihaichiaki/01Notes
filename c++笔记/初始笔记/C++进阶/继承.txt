面向对象三大特性之一 	封装 继承 多态

	封装：数据和方法 放在类里，想给你访问的，放在public，不想给你的，放在private
		进阶一点的：适配器  -- 容器适配器 迭代器适配器

继承：
	
--学校的人员管理系统--				正常情况下，这里类有很多重复的地方。

学生		老师		后勤		这个时候，避免重复 可以放在公共的类里。（成员和成员函数）
_name		_name		....
_tel		_tel				class 基本信息(Person)	此时继承给学生、老师、后勤
id		id				这个类叫做父类（基类）
address		address				继承父类的类就是子类（派生类）
......		......
宿舍号		职称		职能
专业		院系		
班级

继承的意义就是复用。--类设计定义层次的复用。

继承格式：
	class 派生类 : 继承方式 基类

	继承方式和访问限定符：
	访问限定符：public类外可访问 protected、private类外不可访问	访问限定符在类里不受影响
	继承方式：public继承 protected继承 private继承

	继承基类的访问方式：3 * 3  -- >（但是百分之99的情况下是public继承）
	****************************
	public 继承
	基类 	public	protected	     private
	派生类	public	protected     不可见

	protected继承
	基类 	public	protected	     private
	派生类	protected	protected     不可见

	private继承
	基类 	public	protected	     private
	派生类	private     private          不可见
	（不可见也就是在派生类里 也不能访问基类的private的成员）
	（protected、private 类里可以访问，类外不能访问
	不可见类似于隐身，类里类外均不可访问）
	****************************
	注意：
		权限两个合并为权限小的那一个
		私有成员的意义：不想被子类继承的成员，可以设计为私有
		实际开发中，一般使用public继承，很少出现其他继承。同时private基类也很少不想继承给派生类 所以一般使用的是public继承的public	protected成员。
		继承方式不显示写的话，class默认是私有继承，struct默认是公有继承。


继承中的作用域：
	之前见到的作用域：
		命名空间域-- 限制访问
		类域 -- 访问
	基类	--父类域
	派生类	--子类域
（同一个域不可定义一样的成员）
		如果基类有和子类一样的名字的成员 -- 是可以存在的。比如都有一个_name
		但是此时子类对象有两个name，那么此时访问name，优先访问子类的。
		此时想要访问父类的，可以进行域访问限定符 基类::name
			(实际中，建议不要定义同名成员)
	class A{fun} class B : public A{fun(int)} 这fun函数不是重载，而是隐藏。重载要求在同一作用域。想要使用，前面加上访问限定域


赋值兼容转换： 【切片】
	1.子类对象可以赋值给父类对象/指针/引用 -> 大变小 -> 不是同类型，不是隐式类型转换（可以测试 基类& = 派生类对象）
		但是注意，必须是公有继承，其余继承就不行了。
		指针的类型看到的就是子类当中属于父类的那一部分。引用同理
	2.反过来，父类赋值给子类对象是不支持的，强制类型转化也就不行。（指针、引用可以，以后讲）



派生类的默认成员函数：（子类处理自己的，父类的调用父类的处理）
	编译器默认生成的构造函数：
		1.自己的成员，跟类和对象那样。
		2.对于继承的父类成员，调用父类的构造函数初始化。（父类提供默认构造）
（如果不提供默认构造，需要显示的去写）
	显示写构造函数：
		1.不允许直接初始化父类成员，父类和子类必须分开处理。父类调用父类的处理，子类自己处理
		2.类似于匿名对象一样的（初始化：基类(参数)）
	（显示写的构造如果不调用父类的构造编译器会自动生成）
	编译器默认生成的拷贝构造：
		1.自己成员，跟类和对象一样。（内置类型，值拷贝；自定义类型调用它的拷贝构造）
		2.继承的父类成员，必须调用父类的拷贝构造函数初始化
	显示写拷贝构造：
		1.调用父类的拷贝对象（必须调用，编译器不会生成） :基类(子类传入的对象)  -> 这里就是利用的切片原理（系统支持）（也可以利用指针强转，可是没必要））
		2.写具体的深拷贝
	
	编译器生成默认的赋值重载：同上。（内置类型，值拷贝；自定义类型调用它的赋值重载 ，子类处理自己的，父类处理父类的）
	显示写赋值重载：需要调用父类的赋值（也是必须要调用）：赋值调用可以显示调用父类的（注意访问限定，默认局部 -- 隐藏关系（子域和父域出现同名函数，指定调用父类的）））
	

	编译器生成的默认析构：同上（自定义类型调用其析构，内置类型不处理 -- 父类先调用它自己的，然后子类清理）
	**显示写析构：（特殊）
		1.子类的析构函数和父类的析构函数构成隐藏。
			需要指定作用域。
		隐藏：函数名需要相同 -- 那么为什么析构为何构成隐藏？由于后面多态的需要：析构函数会统一处理为destructtor()，所以需要指定调用。	
		但是子类不需要显示调用父类的析构函数，即使显示写，编译器还会在调用一次父类的析构函数。因为为了保证父类先生成，后析构，子类后生成，先析构。 -- 为了保证先进后出的结构 -- 所以每个子类的析构函数后面，会自动调用父类的析构函数，这样才能保证顺序。 -- 规定

	取地址重载 -- > 就不需要合成了，显示写的话也不需要写父类的。

总结：对于派生类，可以自动调用其父类的默认构造（存在参数需要自己调用），析构函数（一定不能自己调用），其余均需要自己去调用。
继承和友元：
	友元关系不可被继承。意思是基类的友元不可访问其派生类的保护、私有成员
	

继承和静态成员：
	-- 整个继承体系里面只有一个静态成员。
	父类和子类（无论多少）共用一个静态成员

----------------------------------
小问题：
如何定义一个不能被继承的类？
--1构造函数私有 C++98（实例化时才会体现出来报错、并且也无法正常对其实例化对象）
--2 关键字：final  -- 这样就不能被继承了。（最终类）
----------------------------------

菱形继承及菱形虚拟继承:
	单继承：一个子类只有一个直接父类时的继承关系为单继承
	多继承：一个子类有两个或以上的直接父类时，这个继承关系为多继承
	有多继承有可能发生菱形继承：问题：数据冗余和二义性
ed：人
学生 	老师
      研究生教员
重复（人的数据） 二义性（访问人的数据的时候，不清楚访问的是哪个 -- 不可明确）
	二义性解决：指定父域即可。
	但是数据冗余没有得到好的解决。
		--java解决办法：除掉多继承
		如何解决此问题：
	*菱形虚拟继承：virtual（在一开始两个类继承同一个类的继承前面加上此关键字即可）
		此时访问第一个基类中的成员就会只存在一份。
	菱形虚拟继承解决了数据冗余和二义性问题
		此虚拟继承是如何解决的呢？
		底层实现：
			菱形继承模型：
			虚拟菱形继承模型：在两个继承类内相同部分变成了指针。验证其指针指向哪里（8字节）但是查看时，两个指针的地方存的是0，往下走一格（4字节），综合这些部分其实就是从此指针位置开始的偏移量--去找公共部分。为何这样设计呢？是为了后序的切片操作，方便用偏移量找到公共部分即可。
		virtual虚继承：虚继承条件下，会在原本继承的内存上多出一个指针（32位 4字节）指针指向一个表，表内就是一个偏移量。（虚基表）这样设计可以和整体进行整合模型。
			
----------------------------------
切片的指针偏移：
	多继承切片规则：
		先继承在前，后继承在后。当进行赋值转化--子类切片操作的时候，先继承的父类成员在前，后面依次，后面才是子类特有的成员。当然，不存在赋值转化也就是子类和子类，这样就在第一个父类成员的开始。此时看的是一个整体。
	（指针类型决定看多大的空间）
	先的地址小，后面的地址大
----------------------------------

总结：
	继承和组合
	（public继承）
		继承是一种is a的关系 -- 每一个子类都是一个父类。 人 - 学生 植物-玫瑰花
		组合是has -a的关系 -- 即在一个类里调用另一个类的一个实例化对象。间接的去用。  车 - 轮胎 脑袋 - 眼睛
	适合哪个就用哪个。当有些类型都可以（is a has a）优先使用组合。比如：vector/list/deque
							              stack
	低耦合，高内聚 ：（软件工程）继承是白箱复用（实现的角度）组合是黑箱复用（功能的角度）
			 	      耦合度高，依赖关系强                 耦合度低，依赖关系低
					（容易互相影响）                （不容易互相影响）
				基类的任何改变都会影响派生类		
	但是组合并不能替代继承。--多态，is a的关系。
	一般虚继承放在共用的基类的直接继承类
