二叉树进阶：

----------真正用来做查找的----------------------
二叉搜索树：（二叉排序树）
	特点：
		左子树的所有结点小于根结点
		右字数上的所有结点大于根结点
		左右子树也必须满足上述特征。
	搜索树最多查找高度次。
	走中序就是一个升序排列数据。

实现：
key - - 

template<class K>
class BSTreeNode
{
 .....
}

Node* _root

bool Instert(const K& key);  插入    搜索树不允许有相同值key值出现，有相同的就返回false，表示插入失败
void InOrder  中序遍历 可以在priavte 套一层，这样就不用传入参数
----实现以上功能 可以实现：排序加去重操作 ----

bool Find 查找
bool Erase 删除（重要）
	一个孩子可以托孤，继承位置即可。（没有孩子可以一并归类）
	两个孩子不可：
		替换法删除。
		找能继承位置的那个人：
			左子树的最大结点（左子树的最右结点）、右子树的最小结点（右子树的最左结点）。
			这两个都可以。
		替换结点赋值给删除结点后，删除替换结点。替换结点要么没有孩子，要么只有一个孩子，可以直接删除。
		// 小心细节处理 
	特殊情况：删除根结点
		不是两个孩子的话：让_root直接执行另一个不为空的子节点即可。

上面删除是循环 -- 非递归--
递归 -- ：
	bool FindR(const K& key)  递归
	bool InsertR(const K& key) 插入  注意查看指针引用结点改为引用 
	bool EraseR(const K& key) 删除
		_(Node*& root, const K& key)
		只有一个孩子或者没孩子类似，但是两孩子可以改为：转化为在一棵子树去删，首先交换数据即可。root->_right, key

// 实际用途上循环会更好
	


	拷贝构造：
		挨个遍历，赋值
	// 强制编译器生成默认构造：BSTree() = default;

增删查的时间复杂度：O（h）h为二叉树的高度 最坏的情况下h = n  单二叉树表 、只有两个树叉 
每个子树均匀--logN   --- 改进方案平衡树。 -- 红黑树、AVL树

区别只是效率不同，功能什么的都相同的



模型：
	key的模型：判断关键字在不在
		1.刷卡进宿舍楼
		2.检查一篇英文文档中单词拼写是否正确
	key/Value模型：通过key去找value
		1.简单的中英互译程序
	查找、插入还是按照K，只不过，还存入一个_value -- 绑定存入一起去。
	查找返回结点，方便进行修改value值。
	删除 -- 同样和key为主。
	

	ctrl Z 换行 -- 或者 ctrl C 可以终止程序





二叉树OJ
......
：递归会栈溢出，改成循环迭代（O1） 借助容器的话一般在堆空间，所以非递归基本忽略不计
前序遍历：递归 - 非递归（）
	根 左子树 右子树 
	（根 左子树 右子树）
	1,左路结点 2.左路结点右子树（子问题）
	一直将左入栈，左走完，访问右结点 条件：cur || !st.empty() 不为空或者还存在右树没有遍历的时候
	cur不为空表示开始访问一棵树
双路递归改为单路循环： -- 一个结点出栈，意味着这个结点及其他的左子树访问完了，还剩右子树。
        stack<TreeNode*> st;
        vector<int> v;
        TreeNode* cur = root;
        while(cur || !st.empty())
        {
            // 开始访问一棵树
            //1、左路节点
            while(cur)
            {
                st.push(cur);
                cur = cur->left;
            }
            TreeNode* top = st.top();
            st.pop();
            cur = top->right; // 子问题访问右子树
        }
        return v;

后序遍历：上述模板不能区分右树是访问过了，还是没有访问过。右子树访问过了，访问根节点。
            if (top->right == nullptr || top->right == prev)
            {
                st.pop();
                prev = top;
                v.push_back(top->val);
            }
            else 
                cur = top->right; // 子问题访问右子树
利用这个判断是否该入此结点的信息。
	
	
	