*非常重要
RAII 利用对象生命周期来控制程序资源（资源请求即初始化）- 资源托管给一个对象，方便自动释放资源。
-利用此思想。

template<class T>
class SmartPtr
{
public:
	SmartPtr(T* ptr)
		:_ptr(ptr)
	{};
	~SmartPtr()
	{
		delete _ptr;
	}
private:
	T* _ptr;
};

完美解决了之前异常所引发的提前跳出的一些内存泄漏的问题。
-此时无论是正常还是异常，都会调用析构函数抛出异常。
上述除外，还需要指针的功能 - 重载运算符：
运算符重载： operator* ->
C++ 库中设计的有很多指针 -- <memory> -头文件
	1.auto_ptr - C++98  -- 管理权转移思路，会导致被拷贝对象悬空 - 对左值动了手脚 - 明确要求不可使用

	// boost - scoped_ptr   shared_ptr weak_ptr 
	
	// C++11 - 
	2.unique_ptr
	*3.shared_ptr
	4.weak_ptr

	

---------------提出问题：
智能指针的拷贝问题
	浅拷贝问题：
1.解决方案：
1深拷贝 -不可，违背了功能的需求 - 我们需求的就是浅拷贝
	库中auto_ptr智能指针解决办法是转移资源，非常不负责任 - 拷贝之前的那个智能指针就会被悬空。
	auto_ptr()

1auto_ptr		管理权转移
	auto_ptr(auto_ptr<T>& ap)
		:_ptr(ap._ptr)
	{
		ap.ptr = nullptr;
	}
	oeprator=(auto_ptr<T>& ap)
	{
		if (this != &ap)
		{
			if _ptr delete _ptr;
			_ptr = ap._ptr;
			ap._ptr = nullptr;
		}

	}

2boost - scoped_ptr/shared_ptr/weak_ptr C++11出来之前均用这些，C++11就吸收为三个，将第一个改为了unique_ptr。

2.1unique_ptr - 唯一指针	只适用于不需要拷贝的一些场景。
	拷贝有问题，不准拷贝！
	operatpr=() = delete; unique_ptr(const unique_ptr& ptr) = delete;
	// 防拷贝 C++11  C++98的话就声明在private

**2.2shared_ptr - 需要拷贝 - 共同管理 - 引用计数

	增加一个计数，每构造一个对象++，析构一个对象--。最后一个对象释放时在把资源带走。
	-不考虑很多因数 - 简单实现
	public:
		构造：++count;
		析构： --_count;  减到0就去释放。
	private:
		T* ptr;
		static size_t _count; 
	--静态似乎可以，但是别忘了，同一类型的类共享。静态成员变量是属于类的。这样的话本来不同指针指向不同的，但是计数却共享，这可不得了，计数就对不上了。
	一个资源配一个计数，多个智能指针对象共管，静态计数对象，所有资源都只有一个计数，静态成员属于整个类。
	所以静态设计方案不可。
	----设计思路：利用一个指针。int* _pCount;
	新来的对象，就在构造函数中即可。每一个资源来的时候就new一个
		构造_pCount(new int(1))
		拷贝构造 两个指针均给我即可，并且++(*pCount);
		析构 解引用进行--即可
		**赋值重载 = 

 				不可直接这么写，会存在内存泄漏。会把其原本指向内容的*pCount给忘记。
				// 不是意味着声明周期到指针才释放，赋值过程中存在释放
			所以，前面应该加上：别忘了自己给自己赋值
			//if (this == &sp) return *this;//可以，但是不好 - 因为管理同一块资源也要走下面
			if (_ptr == sp._ptr) return *this;
			if (--*(_pCount) == 0)
			{
				delete _ptr;
				delete _pCount;
			}		
			_ptr = sp._ptr;
			_pCount = sp._pCount;
			*(_pCount)++;
			return *this;

	-两个大问题：
		1.多线程使用 - 内存泄漏的隐患 - 线程安全
		***2.循环引用。

	struct Node
	{
		int _val;
		Node* _next; -- shared_ptr<Node>
		Node* _prev;  -- shared_ptr<Node>
	}
	shared_ptr<Node>n1(new Node);                	constexpr - 不支持隐式类型转换
	shared_ptr<Node>n2(new Node)
	n1->next = n2;  // 这个时候就不支持了 - 当然里面可以改成智能指针 - 发生循环引用
	n2->prev = n1;  // 极少的场景
	
		函数结束，n2先析构，n1再析构
		_next管着右边的结点内存块
		_prev管着左边的结点内存块

		_next析构，右边结点就释放了，_next什么时候释放呢？n1所在结点被delete，调用析构函数，_next作为成员才会析构。
		_prev析构，左边结点就释放了，_prev什么时候释放呢？n2所在的结点被delete，调用析构函数，_prev作为成员才会析构。

		-shared_ptr本身无能为力。死结很难打开，相互进行牵制。就不会进行析构。

		use_count() - 拿到该智能指针的引用计数。
2.3weak_ptr - 不是常规的智能指针，没有RAII。不支持直接管理资源，主要由shared_ptr构造，用来解决循环引用问题。
	-指针功能完全提供，特点，不参与资源管理，也就是不增加计数。

	辅助型的智能指针、-是shared_ptr的工具人。
	赋值、拷贝 - shared_ptr相关的




引用计数 - 线程安全 -----



// 1.RAII - 托管 2.像指针一样使用  3.拷贝

---------------------------------定制删除器


	前面new 一个元素可以，但是如果new[]呢？
		原本的指针指针 - delete匹配不上（但是一般自定义类型会报错，内置类型没有问题）
		
	new int[5]
	delete [] \ delete -> free()

	new Node[5] - 开空间、调构造函数-malloc + 5 构造函数  	如果析构函数不写，编译器会优化，直接free
		不知道次数   vs下是多开4字节类型大小的空间，用来存储要调用多少次构造或者析构（一般在空间的最前面）ptr会先向后偏移四个字节 
	delete ->1次析构 + free	free(ptr)	
	delete[] -> 5次析构 + free	-> 向前加4字节，去取次数 ，然后调用对应次数析构，然后free((char*)ptr - 4);
	不要抱着侥幸心理，该匹配就要匹配上。

所以，智能指针一般会提供定制删除器delete：
	unique_ptr - 是模板参数	shared_ptr是构造函数重载
shared_ptr是传对象--
	可以提供仿函数
	DeleteArray - operatr() T* ptr delete[] ptr;
	FreeArray - operatr() T* ptr 
	传匿名对象
	
	当然，正常情况下一般提供lambda - 函数对象

unique_ptr就不好传对象了，因为是模板参数 - 不可以传对象
			所以这里一般传仿函数即可。

	
	我们想要支持删除器，能否直接在构造函数给对象呢？ - 本身我们的上面那个架构就不行，所以只能支持template<class D>
	官方库里支持的shared_ptr释放资源不是自己管理的，--单独设计一个类管理引用计数。


-----------------------------------------------------------
面试掌握：
	1.为什么需要智能指针？
		忘记释放	c++11新机制 - 异常安全
	2.RAII：资源交给对象去管理
	3.发展历史：
	4.auto_ptr/unique_ptr/shared_ptr/weak_ptr 区别和使用场景
	5.模拟实现简洁版的智能指针。- shared_ptr
	6.如何解决循环引用，解决原理是什么？

------------------------------------------------------------
内存泄漏：
	不再使用的内存没有得到释放。-错误即逻辑错误。
-经典问题：内存泄漏是指针丢了还是内存丢了？
	指针丢了。指针没丢，那么就不存在内存泄漏。


-内存泄漏什么时候存在危害？
	进程正常结束，内存都会释放掉。（页表映射解掉-）
		1但是进程一点不是正常结束 - 僵尸进程 -- 没有人收拾此进程的后事，没有得到释放。
		2长期运行的程序 - 可用内存越来越少，最终导致系统彻底卡死。

-如何进行避免内存泄漏？
	1.事后检测。-利用内存泄漏的检测工具。
	2.养好编码习惯
	3.RAII进行管理资源。
	4.公司内部规范使用内部实现的私有内存管理库。（原理：申请的内存用容器记录下来，释放内存时，从容器中删除掉，程序结束前，或者没有任务抛的时候，容器中的资源就可能是内存泄漏的）windows hook - 把进程勾过来 - 进行记录
	

	在先前的智能指针shared_ptr 实现中，存在线程安全问题。-因为发生了--&&++，发生了--&&++这个就是属于临界资源，并发执行就可能多次释放，出现了问题！
	所以需要对此计数-- 做互斥锁保护，这样线程就安全了。
	注意锁需要释放。--内存泄漏是非常可怕的。
	这样拷贝和释放智能指针就是线程安全的。
	
