1.多态的概念：
	完成某个行为，不同的对象去完成时会产生不同的状态。

2.成员函数 - 虚函数 - 函数重写
virtual -> 虚函数 （这里和虚继承那里不同，即一个关键字两用）（基类虚函数	必须带此关键字）
	此时继承下来 派生类和基类中同函数（虚函数）（三同：函数名、参数列表、返回值）不构成隐藏，而是重写。不符合重写，就是隐藏关系。


3.多态的两个条件：1.虚函数的重写 **2.父类指针或者引用调用虚函数。
	特例1：子类虚函数没写virtual，也可构成重写 （最好不要不加 virtual）
	特例2：重写值的协变。返回值可以不同，但要求返回值为父子关系为指针或引用。（父是父类指针，子是子类指针）

	虚函数重写是一个接口继承。普通函数继承是实现继承。
		(父类函数的架子)	-- **重写的是实现！	
		注意其中调用父类时传this会发生切片


4.多态的底层实现
	__vfptr -- 虚函数表指针 -- 4字节 
	虚表的本质是一个数组，即函数指针的数组。
	多态的本质原理，符合多态的两个条件，那么调用的时候，会到指向对象的虚表找到对应的虚函数地址，实现多态  --运行时去指向对象的虚表中找到函数指针，进行调用
	普通函数调用，编译链接时确定函数的地址，运行时，直接调用。

	虚函数编译完了，是被存在代码区（任何函数均是，都是放在公共代码段），然后将对应虚函数指针存放在虚函数表中。
	根据切片（父类引用或者指针）调用子类中父域虚函数  -- 构成多态的调用 - 运行时到指向对象虚表中找到虚函数，所以达到了指向谁，调用谁的。  -- 要去虚表中找
	不构成多态，普通调用，编译时确定调用函数的地址	1. 不使用父类指针引用去调用
	2.破坏虚函数重写（1.虚函数） 同样的编译器决议，也不会到虚表中去找，不构成多态。
	但是子类如果没有按照三同来写（ 2.函数名、参数、返回值），还是会到虚表去找。 -- 子类和父类此时都是父类的虚函数。虚表里的函数指针没有被子类重写所覆盖。 -- 不搞重写，凭空定义一个虚函数，白白的浪费资源。


	子类继承父类，父子析构函数会处理为distructor... 这样会方便完成重写。 - 建议继承中析构函数重写。
	父类* p= new 子类 -- 此时delete 就会需要重写。  -- 因为不符合多态，按照对象去找 ，完成析构函数重载，才可以实现。


5.final 就可以表示此虚函数不能被重写。父类 函数名() 后面

	override -- 加载子类函数() 后面 检查子类函数是否完成重写

总结：重载 覆盖（重写）隐藏（重定义）
	重载：两函数在同一作用域 函数名相同参数不同
	重写：两个函数分别在基类和派生类作用域 函数名 参数 返回值相同（协变除外）两个函数为虚函数
	重定义：分别在两个作用域：函数名相同，不构成重写就是隐藏。
	


抽象类 - 接口类：
	*包含纯虚函数就是抽象类，抽象类不能实例化出对象。
	在虚函数后面写上 = 0。（虚函数相当于只是声明一下 - virtual void 函数名() = 0;）
	
	抽象 -- 不对应具体的实体。 ed：植物就是个抽象概念。
	如果想要继承其的类实例化对象，必须要子类去重写这个纯虚函数。  强制多态。
	虚函数的重写实际上就是一个接口重写。（把父类接口的声明拿下来，重写实现）
	


多态的原理：
	同一个类的虚表不同对象，用的都是同一个虚表
	子类完成重写后，子类和父类分开虚表（子类用的是一个，父类用的是另一个）-- 但是不管是否完成重写，子类的虚表和父类的虚表都不是同一个 -- 和编译器相关	子类实现虚表可以理解为写时拷贝。
	如果子类还有一个未重写的虚函数，此时会放在子类的虚表 -- VS监视窗口会隐藏掉。
														**写一个函数打印虚函数表：
		函数指针数组。
		函数指针 重命名： typedef void(*VFPTR) ();  // 和正常的重命名不一样哦
		VS下，函数指针数组下面会给 NULL  // G++下只能写死
		函数指针();  -- 调用函数
		 -- 虚表在对象的头4个字节/8个字节										对象不能直接转，指针之间可以转  *(int*)&对象名   不可(int)对象名 无相关联系的不可直接转
					间接进行强转
		此时传函数指针穿不过去，还要强转一层 (VFPTR*)*(int*)&对象名（取对象头部虚函数指针传递过去）
		-- 可以证明：如果子类还有一个未重写的虚函数，此时会放在子类的虚表
		--*必须要解引用，我们要的是对象前4个字节中存储的虚函数地址。
	


	多继承中的虚表：
		单继承一个类里只有一个虚表。
		继承中算大小 -- 各自算各自的 -- 比如 Base3 : public Base1, public Base2
		此时重写func1 -- （Base 中存在func1） -- 此时Base1 、 Base2虚表都要进行覆盖重写指针。但是看不到子类增加的虚函数。此时子类增加的虚函数（Base3）写入Base1即第一个继承的虚表
	（此时覆盖的指针地址不一样（都是重写的func1） --- 结合汇编进行查看  -- 指针偏移问题 -- 这个问题藏的很深  -- fuc1只有一个）
{符合多态，去指向对象虚函数表找func1的地址调用   ----- 结合汇编，两张表存储的相同函数fun1但是不同的地址，在建立fuc1函数栈帧的时前会jmp -- 此时才会调到真正的函数地址  --  不止虚表、正常函数也是这样的 （单这只是第一个虚表是这样）
	-- 第二张虚表 跳转 会**ecx - 8 （this指针） ...会连续跳几次。
	sub ecx ,8（ecx对象的地址） 


}
		查看第二张虚表的地址的时候：((VFPTR*)*(int*)((char*)&d + sizeof(Base1)))

		实际上：Base2* ptr = Base3的对象  -- 利用切片，此时就可以替换(char*)&d + sizeof(Base1)的内容。
	
	默认搜索只会在局部和全局找。
	语法规定：&类域:函数名 - - 就可以取出对应函数的地址
	
	虚表中虚函数对应指针不同的理解：最终都会调用到存储此虚函数的地址。
		call 和jmp 类似，都是跳转到对应地址。
	

	注意，虽然多继承会有两个虚表，但是如果加入了虚继承，那么就只有一张虚表。

	
多态：
	语法：1.重写的概念及条件 2.多态的概念及条件
	原理：1.虚表是什么 2.多态的原理是什么 3.普通调用编译时决议和多态调用，运行时决议其区别是什么
	
A
B C
D
菱形继承最后的D的构造函数也需要显示调用A的构造函数，因为A为BC共享。并且调用的时候只会调用D中的A这一份，B和C里的就不会去调用。

面试问题：

1.inline可以是虚函数吗？
	可以。inline需要展开，编译时不存在地址，但是虚函数需要将其地址存入虚表中，表现上来说，两者是互斥的。但是需要注意，inline只是一个建议性关键字，关键取决于编译器，不会强制性执行。两者关键字存在的时候，如果是多态调用，编译器会自动忽略inline这个建议，因为没法将这个虚函数直接展开，这个建议无了。不是多态就可以利用此建议。
2.static函数可以是虚函数吗？
	不可以。静态成员函数没有this指针，直接利用类域指定的方式调用。虚函数都是为多态服务的。多态是运行时决议，而静态成员函数都是编译性决议。
3.构造函数可以是虚函数吗？
	不可以。构造函数之前，虚表没有进行初始化。virtual函数是为了实现多态，运行时去虚表找对应虚函数进行调用。对象的虚表也是在构造函数的初始化列表进行初始化的。
4.析构函数可以是虚函数。
5.拷贝构造和赋值可不可以是虚函数？
	拷贝构造不可以，拷贝构造同样也是构造函数。
	赋值可以，但是没有意义。
		（但是可以简单实现一下父类给给子  ... ... ）但是，赋值一般是同类对象之间数据进行拷贝，这样就不存在实际价值。
6.对象访问普通函数块还是虚函数块？
	不构成多态一样快，否则普通函数快。
7.虚函数表是在什么阶段生成的，存在哪里的？
	构造函数初始化列表初始化的是虚函数表指针，对象中也是存的指针。
	存在代码区--利用验证法，和只读常量或者静态变量的地址进行验证。

准备校招面试复习时都要过一遍。					