C：
隐式类型转换：int i ; double d = i;
	意义类型相近的类型 - 比如表示数据的大小。
强制类型转换：
	意义不相近, 但是值转化后是存在意义的。int* p = &i; int address = (int)p;
但是隐式类型转换存在很大的坑。比如在操作数上 比如 > < 都会进行 - size_t N 进行遍历 N >= 0 问题。 0为size_t 类型就会发现问题。


C++：
兼容C语言，精度丢失、代码混乱。
	四种命名的强制类型转化操作符：
	static_cast、reinterpret_cast、const_cast、dynamic_cast;

	1.static_cast -- 意义相近的类型 double a = 1.1; int b = static_cast<int>(a);  //意义不相近会报错 
	2.reinterpret_cast - 意义不相关类型转换int - int* -- 记住哦
	3.const_cast - 消除变量的const属性，方便赋值。const int a = 2; int* p = const_cast<int*>(&a); *p = 3; cout << a <<endl; cout << *p << endl;  -- 打印结果为2 3      （但是编译器观察其内存是修改成3和3的） --- 和编译器相关 - 优化原因，因为认为a不会被改，就不用每次去内存去取了，就放在寄存器读就可以了。所以a虽然内存被改了，但是取a还是去寄存器中取，p还是去内存中去取的。--即编译器编译过的指令-可以看汇编。   -- 很危险。
	解决方法：volatile 在前面加上 - 让编译器不要优化，老老实实去内存里去取。
		c语言里直接转就可以了。
	前三个总结：1.兼容C隐式类型转换和强制类型转换。2.只是期望不要用了，使用规范的C++显示强制类型转换。3.（static_cast-隐式类型  reinterpret_cast、const_cast（强制类型转换））
	4.dynamic_cast - 向下转化：
		父类对象的指针/引用转化为子类对象指针/引用。
父类（向上转换，子->父-没有发生类型转换 - 特例）
子类

	本来类型转换都是会产生临时变量的。const double& rd = static_cast<int>(i);
		那么为什么说上面的那个向上转没有发生转换呢？ - 切片操作。
	
	首先，原本父类对象无法转化为子类的。什么转化也是一样的。
	但是指针和引用是可以的。因为父类指针有可能指向父类也有可能指向子类。-但是存在安全问题 - 越界的风险（有可能本身就是父类的指针）
	使用- 如果原本父类指针指向子类，就返回正确的地址，否则就返回nullptr --- 所以用法此去转是安全的。
	父类必须要有虚函数。否则就不可这么用。


class A1 class A2 class B : public A1, A2;   -- B b;   A1* ptr1 = &b; A2* ptr2 = &b;
	父转化子：1.不用，强制类型转换B* pb1 = (B*)ptr1; B* pb2 = (B*)ptr2; 使用dynamic_cast  -- 区别：两组转换一致。都会将指针偏移到起点。区别的话，没有虚函数-dynamic_cast 就用不了，但是强转可以的。
	
	---- 功能：指向父类还是指向子类。


 
RAII  -- 将资源交给对象去管理。初始化一个对象 资源获得即初始化
RTTI --  typeid(识别类型转换为字符串) dynamic_cast（识别父类指针是指向父类对象还是子类对象）  decltype （用来推导一个对象的类型，可以用来定义另一个对象）  运行时类型识别
	