为什么有AVL树，还需要进行改进呢？（改进成红黑树）红黑树 更胜一筹  -- AVL树左右高度差太严格了
	AVLTree：要求左右高度差不超过1
	RedBlackTree RBTree-红黑树

红黑树：最长路径不超过最短路径的2倍。		不严格的近似平衡->	结果：相对而言，插入同样的数据，AVL树选择更多，红黑树旋转更少。（优势）
	不好的后果：
		AVL树是更严格的logN -- （树高度）
		红黑树 最短的那条路径接近logN ，最长的那个是2logN
		这样进行查找的AVL树会比红黑树查找效率扩大一倍。红黑树会稍微慢一点。
	但是：--实际上这些都是最坏的情况下，本身触发概率小，并且对于现代CPU而言，这样的效率不值一提。关键在于旋转付出的代价小。所以红黑树会更胜一筹。


红黑树的性质：
1.结点不是红色就是黑色
2.根节点必须是黑色
3.如果一个结点时红色的，两个孩子结点必须是黑色的。	树中没有连续的红色结点
*4.对于每个结点，从该结点到其所以后代叶节点的简单路径上，均包含相同数目的黑色结点。	每条路径的黑色结点相等。
//5.每个叶子结点都必须是黑色的。（此处叶子结点是指空节点  -- NIL结点）-- 方便去数路径 同时也满足空树的时候。（没有影响）
	注意路径是要算到空结点。  


上述性质就能保证最长路径不超过最短路径的二倍。
	理论最短全黑：
	理论最长：黑红，黑一样，红数目也一样。一黑一红（不超过2倍）
	
--互斥的规则达到目的，不用刻意去控制，只需要满足性质即可。

	结构和AVL树差不多，只不过不需要bf
枚举
enum Colour
{
    Red;	
    Black;
};
	
	colour _col
	根节点初始化为Black;

新插入结点，插入什么颜色？
	红色：需要满足3 
	黑色：需要满足4
		插入黑色，谁都要杠一下，插入红色，有可能刚，有可能不用。即使刚，也就轻微，而黑色就影响严重了。
	插入-红色

向上检查是否满足规则3：不满足：变色+旋转
		此时连续的两个是红红 -- 此时不可将新插入的变黑（这样就成插入黑了），将父节点变为黑
	此时黑色数量不一致：
		--遇事不决看叔叔（还得是叔叔）存在叔叔捏
		grandfater（黑）->(变红)
	        uncle（红）->（变黑）	parent（红）->（变黑）
				cur（红）
		如果grandfater不是根（子树），此时按照上述步骤继续往上走。
		如果grandfather的father是黑的，那么就结束了，不是连续的红哦~
			此时插入方向改变同理的。
		如果不是黑，那么复刻上述操作，将父亲和叔叔变黑，将
		
		**--但是如果此时叔叔是黑，不能光变色了。就需要旋转加变色。
			


能变色就变色，不可变色就变色加旋转
	需要进行归类：

		g
	p		u
cur

	情况1：cur为红 p为红 g为黑 u存在且为红
		p u变黑，g变红（如果是子树，保持其子树的黑色结点数不变）
		如果g是根，当做cur，往上继续处理。
		如果g出来是根，还要对其进行变黑处理。
	   新增可以在cur的任意子树（最后演化为自己，让自己变红）
	
	情况2：cur在p的左树，cur为红，p为红 g为黑 u不存在/u存在且为黑 		变色+单旋转
		1.u存在且为黑：（一定是cur一下的子树新增。u下面的子树可以是空树或者红节点，p下除开cur的子树是根为黑节点的子树（四种情况，只能是单黑节点））
			p变黑，g变红，同样对g进行单旋。（看g此时在左还是在右）
		2.u不存在：（cur只能是新增，其余节点均没有子树）
			p变黑，g变红，此时对g进行一个单旋即可。
	
	
	情况3：cur在p的右树 cur红 p红 g黑 u不存在/u存在且为黑			变色+双旋转
		类似于情况2，只不过此时新增处于中间位置。
		如果p此时在g的左：
			那么首先对p进行左单旋（其实单旋后此时已经变为情况2了）	然后g进行右单旋，把g变为红，cur变为黑
		相反进行相反旋转即可。

其实还存在两种情况：一是空树，直接插入根即可。二是父为黑，同样直接插即可。

	总结：u不存在或者存在且为黑就要变色加旋转。
	u存在且为红变色继续向上处理。
	（关键还得看叔叔）
	
	注意，上述的cur均可由其子树满足情况1演变而来
	

	assert 是为了debug进行方便的找错误，在re版本下不起作用。

测试红黑树测试高度不靠谱--因为无法确定这是红黑树
--需要检查颜色确定。
	难点在统计每个路径的黑节点的个数。--深度优先遍历-前序递归遍历。递归中，blackNum记录根结点。
	走到空，利用一个数组进行存储。（常规：有点麻烦）
	可以选任意一条路径作为标记（最左或者最右路径 ）benchmark - 基准值
		直接以最左路径（或者最右）
	还要检查是否存在连续的红：可以遇到红，检查父亲的颜色即可。
		
	