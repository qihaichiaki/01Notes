-thread线程库-
c++确认不会抛异常：noexcept

模板+参数
template<classs Fn, class... Args>
explicit thread(Fn&& fn, Args&&... args);  // 仿函数（万能引用，无论右值还是左值都转化为左值）+可变参数
不允许拷贝构造，可以移动构造  -- 右值引用！

join() 线程启动

this_thread :这是一个命名空间，包含此线程相关属性 -- 全局的函数可以获得线程id等信息
yield()：让步---让当前线程让出它的时间片
sleep_for - 休眠...   秒、微秒...

加锁：
-mutex库-
互斥锁
	不允许拷贝
	lock 加锁 阻塞
	try_lock 不阻塞
	unlock

当传局部锁的时候出现了一点问题~
	无论是左值还是右值传递都是拷贝--底层实现机制 可以利用引用对 -- 也就是说在语法识别上面--右值引用的底层实现机制相关。也就是说thread中间还有一层->（但是有完美转发的）所以造成了传参失败

	-可以利用lambda进行捕捉当前域内的值即可，当然也可以传入地址等。

	

对于加锁问题：看谁申请的消耗大。比如如果加锁相对慢的话 -- 那么即使是并行，每次都是申请锁，但是对临界资源消耗低。--那么随着线程切换的话，就会相对较慢 这个时候如果是串行，那么线程切换就会很少，消耗少那么就会很快。

	比如很多人做一件很轻松的事情，需要一个人完成然后叫另一个人继续来重新完成 --- 消耗太多了！
	-因为是互斥锁

如果力度很小，C++内提供了一种操作：原子操作
CAS 原子操作：
	CPU直接支持的指令
	因为可能同时取，但是不可能同时写 -- 系统支持  如果是CAS的话，如果往回写的话只能有一个成功。也就是说，每次写的时候会检查内存中的值和原本的值是否一致，一致就写入成功，如果不一致，那么就说明不是原子操作，那么就写入失败。

C++ atomic 封装了此类
atomic  --直接包此头文件
atomic<类型> 变量 = 初始化;

--此时对此变量操作就是原子操作

力度很小的这种，比互斥锁好多了，不用切换上下文那么消耗大。

-无锁队列-CAS实现的  但是复杂数据结构里面很难用此锁。


注意递归函数里使用锁，很可能造成死锁状态哦


如果在加锁状态中，如果抛出异常，那么就会死锁了。 -- 此时跳出 没有释放锁。
--所以可以利用RAII - 智能管理锁  成员变量必须是引用 - LockGuard    必须在初始化列表里进行初始化
也可以自己手动try 

lock_guard<> lk()  库内提供的就可以


条件变量：
	condition_variable
	注意条件变量本身是要受到互斥锁保护的
	unique_lock<mutex> lock(mtx); // 智能指针  
		唯一锁是在锁定和未锁定两种状态下以唯一所有权管理互斥对象的对象。
	wait(lock);
	wait(lock, 函数对象)  如果函数对象返回true条件满足就往下走，条件不满足就阻塞。并且解锁。
	notify_one() 通知等待的条件变量  
		_all 是唤醒全部
			

// 练习，两个线程交错打印1-100，一个打印奇数，一个打印偶数

可以利用yield() 进行让出时间片的操作 -- 本质是一种自旋锁的方式

注意智能指针shared_ptr 通过引用计数支持拷贝  拷贝是线程安全的，但是访问资源不是线程安全的

STL标准库不是线程安全的

单例模式的懒汉模式

	局部的静态对象第一次调用时进行初始化。
	// 这种写法不通用，要小心，这种写法在C++11之前是不能保证线程安全的。C++11之前局部静态对象构造函数初始化不可保证线程安全的原子性。C++11的时候修复此问题。
	



