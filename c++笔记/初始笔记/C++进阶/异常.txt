exception - 异常
-面向对象处理错误
	C语言传统处理错误方法：1终止程序assert、2返回错误码（）
	
-新增三个关键字：try、catch、throw
try{//捕获的区域}catch(ExceptionName e1){// 异常处理}catch(ExceptionName e2){}...
	throw 在捕获的区域进行抛出异常 - >可以直接到达捕获的地方  -- 类似于传参一样

异常的抛出和匹配规则：
1.异常是由抛出对象引发的。对象的类型决定了激活哪个区域的catch
2.如果存在多个匹配的异常（是在调用链-捕获区域），则匹配最近的那一个（有捕获catch就跳，如果try没有catch就报错）
3catch(...) 可以接收任意的异常对象，上面的catch没有匹配的话就会从这里接收。最后的保险。
4.抛出对象类似于传值返回，返回的是异常对象的拷贝。这个拷贝的临时对象会在被catch以后销毁。
*5.可以抛出派生类对象***-重要，可以使用基类捕获。Exception、派生类。

	抛异常可以抛任意类型对象
	捕获时要求类型匹配
	
实际上使用的时候封装为一个Exception


标准大概 - 服务器的异常开发：（服务端 - 后端）
class Exception
{
	virtual string what();  // 虚函数 - 准备进行多态调用
	string _sql;
	int _id;
}

// 派生类


通常服务器都是一直在运行的。
客户端：PC、App（小程序）、web - （App、web）
（转圈圈 - 重复发送请求）

trow了几套体系，catch几套体系即可。

-----------------
存在一些异常需要重复抛出、即对于某些异常重复进行检测：
	try{}catch(){};  // 此时在中间截胡一下。但是注意内部捕获相同的错误，就不会往外传了：所以此时想要继续向外面传递的话那么就是异常的重新抛出即可。注意catch必须对应对应的try
	catch（...） 里面throw; 捕获的任意异常也会重新抛出
	但是也还是存在由异常引发的内存泄漏 - 需要手动释放的问题。-C++智能指针能够解决这种问题。

--------------
异常安全：
	1.不要在构造函数中抛异常。
	2.析构函数中不要抛异常。内存泄漏
	3.new、delete - lock、unlock C++一般用RAII解决此问题。

-------------
异常规范
	在函数后面加上 throw(异常类型) 表示可能抛出哪些异常，没有异常可抛类型就写空 -- C++98规范的
	无异常接口声明，则此函数可以抛任何类型的异常。 
	noexcept;  // C++11 表示不会抛异常
---注意不是强制性的，兼容C语言
------------
C++标准库的异常体系：
	std::exception
	<exception> 
-----------
优点：调用链很深，能直接调到外面。
第三方库也都包含异常。
 对一些函数调用，也适合使用异常。

缺点：
	程序执行流的乱跳。
	性能的开销
	没有垃圾回收机制，资源需要自己去管理
	C++标准库定义的异常不好。
	异常尽量规范使用：1.抛出异常类型都继承自一个基类，2.函数是否抛异常，抛出什么异常throw进行规范化。
但是总体优点大于缺点 - 。	