test.c      编译          链接           test.exe

声明中函数的形参名可以省略

函数如果在main函数后，需要先声明后使用

一般使用函数时，都是把函数放在main前面的

*自己的头文件   add.h  用于声明  add.c函数的代码     在主函数里面引用的那一页需要预处理:
#include"add.h"  自己创建。  ＜ ＞是库函数 ，""是自己创建的

*做到只把头文件给别人，源文件不暴露
如果不愿意暴露代码，将其编译成静态库.lib-
相当于将.c文件进行封装，模块属性，lib，生成。
导入静态库
#pragma comment (lib,"add.lib")
还需要预处理，需要拿进add.h,add.lib放入文件夹即可

程序调用自身的编程技巧称为递归   把大型问题层层转化为与一个原问题相似规模小的问题进行解决  把大事化小
如果递归死循环会报错:栈溢出
找到不需要调用的那个条件和一开始需要执行的环节，然后逆向退理，知道全部执行完
递归，先递推，然后在回归。
两个必要条件:
1.递归存在限制条件（即满足时不在递归）
2.每次都在接近递归结束的条件

*每一次函数调用都会在栈区开辟空间（无论是什么函数），调用结束空间即被释放。这就是如果递归死循环，每次调用都会在栈创建空间，直到没有，即栈溢出。

迭代即循环的方式

斐波那契数列
1 1 2 3 5 8 13 21 34 55.....
有时候，有些问题用递归不合适，效率太低了，计算机重复次数太多，导致运算速度极慢，这个时候就不要用递归了。

*用递归写起来非常简单，效率没有缺陷，就可以用，如果效率存在缺陷，就不能用递归。

*递归经典问题:
汉诺塔问题   青蛙跳台阶

const 修饰变量，指定其不可修改，间接虽然可以修改但会报错（如通过指针）
修饰指针
const在*的左边:常量指针，即，不能通过这个指针改变变量的值，通过其他方式可以，但是常量指针指向的地址也可以发生改变
const在*的右边:指针常量 ，即，指针本身是个常量，不可指向其他的地址。但是在这个地址的值还是可以改变的

*注意a*1.0/b和a/b*1.0的区别，如果a和b都是整型，那么只有第一个式子有意义，a乘以1.0转化为浮点数，除以b得浮点数，如果是第二个式子，那么就先两个整型相除，达不到转化为浮点数的效果比如5/2第一个式子就得到2.5，而第二个式子是2.0