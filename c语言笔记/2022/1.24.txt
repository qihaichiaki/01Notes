连续赋值少写

c语言中c99之前没有表示真假的类型
c99中引用了bool类型可以表示
头文件stdbool          _Bool flag = ture/false(1/0)
bool flag2 = ture

&用于取地址的话只要对象开辟了空间就可以取出你的地址

sizeof内部的表达式不参与计算,是在编译期间处理
s是short，a是int类型
sizeof（s =a +2）
test.c   编译       链接        test.exe
             编译的时候都处理为2了（s=a+2）

*注意传参的时候，传过来的参数进行sizeof时看看是不是指针类型的地址，地址就统一是4/8，地址的储存大小呀

scanf读取失败会返回eof -1 所以多组输入就可以引用~        while（~scanf()）

++a  a=a+1 a
a++  a a=a+1

字符串两个比较（直接用==比的话比较的是首元素地址（字符串不一定是有内存的，比如在初始化的时候（指针时除外）strcmp是用来比较对应位置上字符的大小

&&逻辑且左边有假右边的运算就不进行了
同理 ||逻辑或左边有真，右边也就不用进行了

逗号表达式，从左执行到右边，最后返回最右边的值

[]就是一个操作符arr[4]和4[arr]完全等价

调用函数时函数名后面的括号为函数调用操作符，操作数参数和函数名

结构体变量.成员名
结构体指针（指针变量）-＞成员名


表达式求值有些操作数可能先转化类型，然后优先级和结合型

c的整型算术运算总是至少以缺省整型的精度来进行的，表达式中的字符或者短整型先转化为整型，进行整型提升。（大小小于int的）
一个整型放在字符型里要发生截断，一个是32比特位，一个是八比特位。
整型提升就是按数据类型的符号位来提升的（无符号高位补零）
*在内存里面就是补码

*大于等于整型运算时转化为大于的类型进行运算（隐形的）算术转换

*表达式求值无法确定唯一计算路径就存在问题