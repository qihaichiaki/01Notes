阶乘相加的简洁
避免很多重复的计算
int ret = 1；
for（int i=0；i＜n；i++）
{
    ret *= n；
    sum += ret；
}

越界访问需谨慎！很有可能栈重复，导致死循环的情况。但是在release版本下会优化，不会死循环。（不同环境下可能表现不同）

内存
栈区
局部变量，函数形参

堆区


静态区

*栈区（栈区的使用习惯:先使用高地址处的空间，再使用低地址的空间）
高地址

i
arr





低地址

写出易于调试的代码
优秀的代码:

*模拟实现strcpy
也要进行优化
void my_strcpy（char* dest，char* src）
    while（*dest++ = *src++）
    {
        ；
    }
7分
但是一个指针赋成空指针，如果对空指针解引用就有问题。
所以就要断言assert（表达式）断言函数，表达式为假就会报错。需要引用assert.h的头文件。
所以可在while循环前面加一个
assert（dest ！= NULL &&src！=NULL）||assert(dest &&src)；
NULL可表示0
8分

加载一个const那么就说明了右值必须能够修改。这样可以避免while循环里面出现的逆转错误。
const是可修饰常变量的，不可被改哦。
*注意const int* p只限制*p，不限制p，表示p指向的对象不能通过p来进行改变。但是p变量中的地址是可以改变的。
int *const p=这里就只限制p，不限制*p了。表示p的内容不能被改变，但是p指向的对象可以通过p来改变。
左定值右定向。
这样的话，咋们的mystrcpy更加健壮。
之后进一步优化就是返回目标字符数组的首地址，这样就可实现链式访问了。
设计返回值类型是为了实现函数的链式访问。
这样一来，咱们的程序就能得十分了。