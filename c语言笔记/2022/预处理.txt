任何c语言的实现中都有两个环境
test.c                    编译器                              test.exe                操作系统                      结果
源代码                  翻译                                  可执行程序            执行环境                    结果
1.翻译环境 源代码转化为可执行的机器指令
2.执行环境 实际执行代码
开始执行代码 创建运行时的函数堆栈   程序员的自我修养

每个源文件经过编译器都会生成一个目标文件 .obj 再将全部的目标文件加上链接库，通过链接器处理得到可执行程序。
即 先编译（编译器），然后链接（链接器）

链接库:库函数以来的库文件
第三方的库

extern声明外部符号

集成开发环境 ide   编辑 编译 链接 调试  vs2019中编译器 cl.exe   链接器link.exe

编译阶段分为三个阶段：预编译（预处理） 编译 汇编
1.预编译 头文件的包含#include预处理指令#define执行查找替换，#if可以区分是否编译，#undef可以反定义，也就是取消#define宏定义的东西
#define也是在阶段完成 预处理指令。
注释也是在这里删掉
2.编译    会产生.s的文件 即汇编代码 将c语言代码翻译成了汇编代码
过程难 语法词法语义分析，符号汇总
具体说一下符号汇总：
汇总全局的 比如外部声明的函数名 main等 函数名
3.汇编
产生(windows环境下).obj linux下是.o文件。
将汇编指令翻译成了二进制指令。
形成符号表：（与2中的符号汇总有关）
将2中的符号汇总，进入3后会形成符号表 符号所对应的地址 就在该.o文件定义的符号里面存放真实的地址，外部声明的放的不一定是真的。

然后将所有.o(.obj)链接起来生成.exe文件        1.合并段表 2.符号表的合并和重定位
所以执行2的时候会发现有的相同符号有不同的地址，其中一个是有效地址，一个无效地址，合并起来形成有效地址即可，达成外部引用。（跨文件找）这就是符号表和符号汇总之前在汇编和编译中的作用。

上面总的来说：
预处理：相当于根据预处理指令组装新的C/C++程序。经过预处理，会产生一个没有头文件（都已经被展开了）、宏定义（都已经替换了），没有条件编译指令（该屏蔽的都屏蔽掉了），没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。

编译：将预处理完的文件逐一进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。编译是针对单个文件编译的，只校验本文件的语法是否有问题，不负责寻找实体。

链接：通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。 链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。在此过程中会发现被调用的函数未被定义。需要注意的是，链接阶段只会链接调用了的函数/全局变量，如果存在一个不存在实体的声明（函数声明、全局变量的外部声明），但没有被调用，依然是可以正常编译执行的。

linux vim 非常强大


预处理详解：
常见宏：
__LINE__（行号）
__FILE__  打印所在文件
__TIME__  打印编译时间
__DATE__  打印编译日期
__FUNCTION__（函数名）
__func__ 当前函数的函数名   程序日志 c语言中定义好的符号写入即可

vs不遵循标准c语言 但是gcc遵循。
