## 规划  
* 图形学技术判断一个简单的标准：画面亮不亮  
* 特效，是最简单的图形学应用？最困难的反而是比较日常相关的  
* 图形学的范畴：游戏、电影特效（模拟）、动画、计算机设计CAD、可视化、虚拟现实（看不到现实）VR增强现实AR（看得到现实）、电子绘画、GUI  
* 图形学包括的内容：  
	1. 数学  
	2. 物理仿真  
	3. ...  
* 为什么学计算机图形学？图形学厉害！  
* 后续的知识：光栅化（OpenGL、shader）、曲线和曲面（几何）、光线追踪、动画与模拟  
1. 光栅化  
	* 是什么？三维空间的几何形体显示在屏幕上  
	* 实时：每秒生成30帧  
2. 几何  
	* 光滑曲线、曲面  
	* 形状变化、拓扑结构  
3. 光线追踪  
	* 生成质量更高的画面  
4. 动画与模拟  

* 先学知识，后使用图形学API  
* 注意：一切需要猜测的东西->计算机视觉，不属于计算机图形学的范围  
* 不同领域之间有什么区别？  
	- MODEL（描述）<--> IMAGE（渲染）  
	- 模拟到模拟-图形学		图像到图像-视觉  

## 向量矩阵-线性代数  
* 图形学依赖于：基础数学、线性代数、基础物理、美学  

### 向量  
* 矢量、向量。表示的是一个方向  
* 向量的属性：方向、长度  
	- 长度：提供一种单位向量-长度为1即可  
		* 单位向量：向量除以向量的长度  
	- 方向：一般使用单位向量只表示方向  
* 向量移动到不同的位置仍然不会改变  
* 坐标表示默认列向量  
* 向量的操作：  
	1. 向量的求和：  
		- 几何理解：平行四边形法则、三角形法则（向量首尾相连）  
		- 代数理解：坐标直接相加  
			* 采用直角坐标系-笛卡尔坐标系  
	2. 向量的点乘：  
		- 标准定义：两个向量的长度乘以其夹角的余弦值  
		- 向量点乘得到的是一个数。图形学的应用中可以方便快速得到**两个向量之间的夹角**。对于单位向量来说，余弦值就是两个向量的点乘  
		- 代数解释：  
			* 满足交换律、结合律、分配律  
		- 在笛卡尔坐标系下：  
			* 点乘就是对应元素相乘并且相加。高维度同样如此  
		- 一些应用：  
			* 向量在另一个向量上的投影（比如b投影到a向量上）。b投影向量的方向和a向量一致（b向量长度就等于a的单位向量乘以长度即可）。构建成直角三角形，算出余弦值（根据b向量和b投影向量），b投影向量的长度就是b向量的长度乘以夹角余弦即可。投影向量的好处：这样就可以算出两个方向的向量。（减法）  **对于任意向量可以做到垂直与平行的分解**  
			* 两个向量方向上否接近  
			* 前与后的信息（在一个圆上，分上下部分，利用点乘）  
	3. 向量的叉乘：  
		- 计算出另外的一个向量，并且新向量和输入的两个向量都需要垂直  
		- 新向量的大小代数公式：输入的两个向量大小相乘在乘以其夹角的正弦值  
		- 新向量的方向：右手螺旋定则（点赞：从第一个向量绕向第二个向量为除开拇指的其余手指的蜷缩方向，那么拇指指向的就是新向量的方向）-这里可以扩展得到两个向量的叉乘，并不满足其交换律，因为方向相反  
		- 叉乘的性质：  
			* 自己叉乘，长度为0（正弦值为0）的零向量(只有方向)  
			* 分配律和结合律仍然存在（交换律是方向相反的值）  
		- 叉乘的代数方式：  
			* 笛卡尔坐标系下。。。?矩阵相关  
		- 叉积的作用：  
			1. 三维空间的直角坐标系  
				* 如果x向量乘以y向量等于z向量，说明是一个右手坐标系  
			2. 图形学用处：左和右（通过叉乘的结果向量方向进行判断（利用右手螺旋定则））、内和外（内部和外部通过左和右去判断。比如判断一个点是否在三角形内部，那么点始终和边在同一方向）-光栅化的重点（给三角形区域内填色，判断像素点是否在内）  

### 矩阵  
* 图形学里，变换是矩阵最大的应用  
* 矩阵的操作：  
	1. 乘以一个数（矩阵内均乘）  
	2. 矩阵的乘积  
		- 可以乘的矩阵：第一个矩阵的列数必须等于第二个矩阵的行数``(M*N)(N*P) = (M*P)``  
		- 计算方式：  
			1. 先将大小定下来  
			2. 对于输出结果的第N行和第P列的数的求解，分别在输入矩阵内的第一个N行和第二个P列，进行相乘相加（依次相乘（行对列）最后相加。就是一个点积）  
	3. 矩阵的转置：``NXM -> MXN``  行和列互换  
		- 性质： (AB)转置 = (B)转置(A)转置  
	4. 特殊的矩阵，单位矩阵：  
		- 对角线上为1，其余为0  
		- 作用，定义矩阵的逆：如果一个矩阵和一个矩阵相乘为单位矩阵，那么这两个矩阵就是互逆的  
		- 也存在性质：(AB)逆 = (B)逆(A)逆  
* 矩阵的性质：  
	- 没有任何的交换律，矩阵的结合律和分配律存在  
* 矩阵和向量计算  
	- 向量为列向量``（M*1）``存在意义，始终认为矩阵在左边``(x*M)``，向量在右边  
	- 在进行几何变换中意义非常大  
	- 向量的点乘和叉乘都可以写成矩阵的形式：  
		* ``a*b`` => ``(a矩阵)转置乘以b矩阵``  
		* ``axb`` => ``A矩阵（a列矩阵变化而来）乘以b矩阵``  


## Transform变换  
* 变换分类：1.Modeling 模型变换、2.Viewing 视图变换  

### 2Dtransformations  
#### Linear transformation 线性变换
##### Scale Transform 缩放变换  
- ``x' = sx; y' = sy`` 同比例缩放  
	* 转换为矩阵形式：  ``[x' | y'] = [s 0 | 0 s] [x | y]``  
- ``x' = Sx*x; y' = Sy*y`` 不同比例缩放  
	* ``[x' | y'] = [Sx 0 | 0 Sy] [x | y]``  

##### Reflection Matrix 反射矩阵  
- ``x' = -x; y' = y`` 反射、按y轴对称  
	* ``[x' | y'] = [-1 0 | 0 1] [x | y]``  

##### Shear Matrix 切变矩阵  
- 比如将边为1的矩形沿水平方向拉伸，特点有：1.竖直坐标没有发生变化、2.y=0时的水平方向的坐标没有发生任何改变（平行四边形的底边）、3.y=1（最上面边），都移动了a这个距离（x原始坐标 + a）=> 水平方向上移动了多少？``a*y``  
- 矩阵应该长这个样子：``[x' | y'] = [1 a | 0 1] [x | y]``  

##### Rotate Transform 旋转变换  
- 默认情况下：绕着原点（0, 0）进行旋转，逆时针方向  
- 利用单位矩阵和三角函数，可以很简单的推导出变换矩阵的关系：  
	* ``R = [cosθ -sinθ | sinθ cosθ]``  
- 对于旋转矩阵，还存在几个不错的性质：  
	* R(-θ) = (Rθ)T = (Rθ)^(-1)  

##### 变换的共同点  
- ``x' = ax + by; y' = cx + dy``  
- ``[x' | y'] = [a b | c d] [x | y]``  
- 类似于上述矩阵，输入得到变换后的结果，此变换即为线性变换  
- Linear Transforms -> x' = Mx  

#### Homogeneous coordinates 齐次坐标  
* 引入：对于平移变换来讲，比如x方向移动Tx，y方向上移动Ty，那么坐标的变换公式如下：  
	- ``x' = x + Tx; y' = y + Ty``  
	- 但是如何写成之前的矩阵形式呢？  
	- ``[x' | y'] = [a b | c d] [x | y] + [Tx | Ty]``  
	- 说明平移变换并不属于之前线性变换的范畴  
	- 但是，不想让平移每次以这种特殊的形式呈现。懒->**有没有一种方式将之前和这种简单的变换统一成一种方式进行表示**呢？  
	- 引入齐次坐标的概念  

* 对于2D来说，我们可以增加一个维度。这样，其实对于之前的线性的表述：``x' = ax + by``可以变为``x' = ax + by + z`` 这个z是自由的，不会受到输入x、y的影响  
* 此时平移变换的矩阵表达式如下：  
	- ``[x' | y' | w'] = [1 0 Tx | 0 1 Ty | 0 0 1] [x | y | 1] = [x + Tx | y + Ty | 1]``  
* 对于增加的维度来说：  
	- 2D的point：``[x | y | 1]``  
	- 2D的vector：``[x | y | 0]``  
		* 向量的变换，存在不变性，那么不应该得到别的向量。比如经过平移变换后不变  
		* 深度考虑：向量和向量相加（三角形首尾相连法则）、两个点相减（形成了被减数到减数的向量）、点加向量（点）、点加点（???）...  (1表示点，0表示向量。是存在意义的)  
	- 扩充的定义：（一个点加另一个点，在齐次坐标下就是表示之间的中点，可以看下面的定义）  
		* ``[x | y | w] point => [x/w | y/w | 1]``  

* 类似平移这样的变换，为仿射变换Affine Transformation（线性变换 + 平移操作）  
	- ``[x' | y'] = [a b | c d] [x | y] + [Tx | Ty]``  
	- 齐次坐标的形式：``[x' | y' | 1] = [a b Tx | c d Ty | 0 0 1] [x | y | 1]``  
	- 仿射变换下，变换矩阵的最后一行始终为``0 0 1``  

* 那么代价呢？额外的数字  

##### Inverse Transform 逆变换  
* 类似于经过一个变换M后，在乘上变换的逆M^(-1)得到原来的矩阵 => AMM^(-1) = A(MM^(-1)) = A  

#### Composing Transforms 组合变换  
* 类似于将之间不同的线性变换、平移变换组合在一起进行变换  
* 变换的种类加顺序（理解：矩阵的乘法不满足交换律）是十分重要的。复杂的变换分解为小的简单的变换  
* 一般计算时候，写的方式为：``T(1, 0)*R45[x | y | 1]`` 矩阵运算严格要求从右到左的顺序进行计算  
	- ``An(...A2(A1(x))) => An...A2*A1*[x | y | 1]``  
	- 矩阵虽然没有交换律，但是有结合律  
	- 可以看到，一个非常复杂的变换任然可以用``3*3的矩阵（An...A2*A1）``进行表达，使用矩阵是非常牛逼的  

* 变换的分解：  
	- 例子，之前的旋转变换是基于原点进行变换的。现在我们想绕着任意一个点进行旋转，可以将其拆解，先将想绕的点的位置（当然是整个也要全部移动）平移到原点，然后旋转角度，最后在位移回去。三个步骤  

### 3D Transforms  
* 利用2D拿去做对比即可  
* 对于3D坐标中的齐次坐标：  
	- point：(x, y, z, 1)T  
	- verctor = (x, y, z, 0)T  
	- 特殊定义：(x, y, z, w) => (x/w, y/w, z/w, 1)这样的点  

#### 3D空间中仿射变换齐次坐标表示  
* ``[x' | y' | z' | 1] = [a b c Tx | d e f Ty | g h i Tz | 0 0 0 1] [x | y | z | 1]``  
* 特点：  
	- 最后一行对于仿射变换来说，还是``0 0 0 1``  
	- 平移任然还是``Tx Ty Tz``  
	- 剩下的3x3的矩阵表示的就是3维空间中的线性变换（缩放，切边、旋转、反射）  

* 问题：这样的变换式子是先线性变换然后平移还是反过来的呢？  
	- 先线性变换，再平移  
##### 缩放  
* S(Sx, Sy, Sz) = [Sx, 0, 0, 0 | 0, Sy, 0, 0 | 0, 0, Sz, 0 | 0, 0, 0, 1]  

##### 平移  
* T(Tx, Ty, Tz) = [0, 0, 0, Tx | 0, 0, 0, Ty | 0, 0, 0, Tz | 0, 0, 0, 1]  

##### 旋转  
1. 绕着轴进行旋转：  
	- Rx(a) = [1, 0, 0, 0 | 0, cosa, -sina, 0 | 0, sina, cosa, 0 | 0, 0, 0, 1]  
	- Ry(a) = [cosa, 0, sina, 0 | 0, 1, 0, 0 | -sina, 0, cosa, 0 | 0, 0, 0, 1]  
	- Rz(a) = [cosa, -sina, 0, 0 | 0, sina, cosa, 0 | 0, 0, 1, 0 | 0, 0, 0, 1]  
2. 任意位置旋转  
	* 3D的任意旋转可以用简单的轴旋转得到：  
	* Rxyz(a, b, r) = Rx(a)Ry(b)Rz(r)  
	* 基于一个飞机转向的想象：左右Yaw、上下Pitch、自转Roll  
###### Rodrigues' Rotation Formula 罗德里格斯旋转公式  
* ``R(n, a) = cos(a)I + (1-cos(a))nnT + sin(a)[0, -Nz, Ny | Nz, 0, -Nx | -Ny, Nx, 0](N个)``  
* 对于旋转轴，光向量是不行的，还是必须要得存在起点。但是默认旋转轴是过原点的（起点）  
* 类似的，如果起点不在原点上，可以和2D一样的做法，先通过平移转换移动到原点，然后进行旋转，最后在进行平移回去  

### Viewing Transformation 观测变换  
* 将三维中的东西，变成2维中的照片  
* 以现实生活为例：  
	1. 人集合在一起，摆好poss（model transformation 模型变换）  
	2. 找一个好的角度和位置，对于相机（view transformation 视图变换）  
	3. 茄子！（projection transformation投影）  
* mvp变换。  

#### View/Camera Transformation 视图变换  
* 摆一个相机  
	1. 放在哪？Position e  
	2. 往哪里看？Look-at/gaze direction g  
	3. 本身的旋转-确定向上的方向？Up direction t  
* 可以认为相机永远不动，并且，**永远放在原点**，**永0远向-z方向看**，**永远以y轴为向上方向**  
	- 具体操作：e先平移到原点上、g旋转到-z上、t旋转到y上  
	- 矩阵方式：  RviewTview  
		* Tview：``[1, 0, 0, -xe | 0, 1, 0, -ye | 0, 0, 1, -ze | 0, 0, 0, 1]``  
		* Rview: 正向不好旋转，可以逆向思维求逆即可，也就是反过来z旋转到-g上、y旋转到t上，x旋转到（g x t）  
			- Rview^(-1): ``[Xgxt Xt X-g 0 | Ygxt Yt Y-g 0 | Zgxt Zt Z-g 0 | 0 0 0 1]``  
			- 可以分别利用X轴向量``[1 | 0 | 0 | 0]``... 进行验证得到g x t的向量。因为求出来是逆，根据旋转的特点，R(a)^(-1) = R(a)T = R(-a) 通过置换即可得到Rview  
	* 所有都要变换，也就是和相机的相对位置不会发生变换。所以一般模型和视图变换都是放在一起的进行变换  
#### Projection Transformation 投影变换  
* 正交投影，不会带来近大远小的特点，透视投影可以带来。并且透视线相交，正交线相互平行  
##### Orthographic projection 正交投影  
* 假设相机离得无限远  
* 将z轴扔掉  
* 正规做法，移动到原点，然后6个面 方向均压缩到[-1, 1]  
* 利用相似三角形：``y' = n/z * y`` n为近平面的坐标，f为远平面的坐标  
	- [nx/z | ny/z | 未知 | 1] => [nx | ny | 未知 | z]  
* 对于未知就是z的变化，对于任何一个点在近平面、远平面上：z不会发生变化  
	- 设置z为n，那么就是[x | y | n | 1] => [nx | ny | n^2 | n]  
	- ``[0 | 0 | A | B] [x | y | n | 1] = n^2``  
	- 远平面上的中心点  
##### Perspective projection 透视投影  
* 空间中存在一个点，由此点衍生出一个四棱锥  
* 可以将一个四棱锥，后面的远处平面挤为正交的矩形，在进行正交投影  
* 规定：近平面不变，远平面的z值不变  

