冯诺依曼体系结构：
输入设备  存储器 运算器 控制器 输出设备

存储器：内存
输入设备：键盘，摄像头，话筒，磁盘（读取），网卡
输出设备：显示器，音响，磁盘（写入），网卡......
中央处理器（cpu）：
	运算器：算术运算，逻辑运算
	控制器：cpu响应外部事件的，协调外部就绪事件（比如拷贝数据到内存）


输入设备本质：产生数据的的
输出设备本质：保存和显示数据的

1.cpu&&寄存器的运算速度 > 内存 > 磁盘/SSD(固态硬盘) >光盘 >磁带
2.木桶原理：整体效率是由最慢的那个效率挂钩的
3.成本原因

冯诺依曼体系结构本质：
1.cpu读取数据（数据 + 代码）,都是要从内存中读取。站在数据的角度，我们认为cpu不和外设直接交互
2.cpu要处理数据，需要先将外设中的数据，加载到内存。站在数据的角度，外设直接和内存打交道
输入设备 -> 存储器 input        I 
存储器 -> 输出设备 output     O

程序要运行，必须加载到内存里     因为是由冯诺依曼体系结构决定的
（程序 -- 文件，磁盘）
 流向：输入设备 -- 存储器 -- cpu -- 存储器 -- 输出设备




操作系统：
用户：指令操作 开发操作 管理操作							c库 c++库
用户操作接口：shell外壳 lib 部分指令 （为了能够方便进行调用和会使用接口，所以就有了这些。对系统调用接口的封装 -- 第三方库）
system call：系统调用接口 （操作系统对外（用户）提供系统接口 Linux用c语言写的 本质就是c语言提供的函数）
操作系统：内存 进程 文件 驱动	        -- 操作系统内核
驱动程序：
底层硬件



理解先描述在组织：
管理者和被管理者可以不直接交流
只需要拿到被管理者的数据，才支持管理决策   -- 即对被管理者的数据进行管理
但是管理与被管理者之前需要一个提交数据，和一个执行命令的中间层次 -- 执行者
管理者 -- os（操作系统）
执行者 -- 驱动
被管理者 -- 硬件
*管理，是对被管理对象的数据的经理。
	决策进行：先对被管理对象进行描述，组成成数组  -- > 管理工作就变为对数组的增删改查；
*管理：先描述，在组织
          （Linux内核是用c语言写的，struct！！结构体）
操作系统（OS）内：一定存在大量的数据结构和算法 




进程  -- 代码和数据，以及对应匹配包含其属性的结构体（PCB）
其实，自己启动一个软件，本质就是启动了一个进程。
在Linux下，运行一条命令，./xxx，运行的时候，其实就是在系统层面创建了一个进程！！（所以由冯诺依曼加载到内存的程序实际上就是一个进程，才能被操作系统管理）
Linux是可以同时加载多个程序的，Linux是可能同时存在大量进程在系统中的。

所以操作系统需要管理大量进程。--即先描述，在组织。
OS会为每一个进程申请一个结构体PCB（struct包含了该进程的所有属性） -- 描述进程
	程序文件加载到内存是内容加载进去，属性没有，被加载到该进程的属性里去。（文件 = 内容 + 属性）
所以，上述对进程的管理就变成了对进程PCB结构体链表的增删改查


进程模块化
PCB ：Linux struct task_struct{};
查看进程：ps ajx（axj） | head -1头部信息 &&
ps ajx --当前所有进程 加上管道和grep可以快速查找自己想要的
查看详细属性：（ls /proc/进程ID--PID唯一）用文件的方式查看进程
exe->所在的目录
cwd->当前进程的工作目录：
	c语言中的FILE *fp = fopen("路径", "w");--以写入的方式打开  没有带路径--默认打开当前路径
	bin（exe） -> 运行的->每个进程都会有个属性,来保存自己所在的工作路径。
		

struct中的标识符 --： 
在代码中获取当前进程的PID：头文件 sys/types.h  unistd.h
	pid_t id = getpid();

杀掉进程命令：kill -9 PID   -- 终止进程
进程有父子关系：
 pid_t getppid(void) 获取父进程id
--父进程永远就是bash -- shell外壳程序创建子进程
	bash pop掉就无法正常运行指令 （命令行解释）

代码层面上调用系统接口：fork
	--创建子进程 头文件unistd.h    pid_t fork(void);
		返回值：a、-1 失败  b、成功时 给父进程返回子进程的pid ，给子进程返回0（特殊函数 -- 成功具有两个返回值）
	fork之后就是该进程的子进程
	在一个普通c文件里面写上：
		pid_t t = forl();
		printf("%d",t);
	此时一运行的t值一个就是子进程的PID，一个就是0.其中一个是运行的是父进程，另一个是子进程。



	fork基本用法：
		fork之后，父子共享代码。如何控制父子做不同的事呢？
		利用if （perror 是c语言中报出错误原因的函数）对获得fork的pid进行判断即可。父进程的是子进程的pid，子进程获得就是0。
while :; do ps axj | head -1 && ps ajx | grep myproc | grep -v grep; sleep 1; echo "#######################"; done 每隔一秒监控此进程（myproc）
	为什么给子进程返回0，给父进程返回子进程的pid
	父进程：子进程 = 1：n  -- 表明关系
		一份代码有两份死循环代码执行，表示有两个不同的执行流，即两个进程。

	为什么会有两份返回值：在创建进程的时候，OS 多了一个进程 -- 系统调用 操作系统内部：新建一个struct task_struct，以父进程的属性为模板进行拷贝到里面去，（不是完全复制，比如pid）
	*cpu在执行进程的时候，会创建一个run_queue 运行队列     -- 操作系统和cpu运行某一个进程本质是从task_struct形成的队列出的一个struct，来执行其的代码。--进程调度，变成了在task_struct队列中选择一个进程的过程。
	从fork函数内部（系统OS）return开始父子共同执行一段代码。-- return就被执行了两次。

	父和子进程被创建出来后，先后运行不一定 -- 操作系统的调度器决定的。



struct{...int status;...}
进程状态：（理论状态）-- 计算机操作系统原理 -- 计算机的哲学
	新建：字面意思  没有入队列（实际上Linux上没有此状态，一般建立了就加载到运行队列中了）
	运行：task_struct 结构体在运行队列中排队，就叫做运行态*
	阻塞：等待非cpu资源就绪，阻塞状态
	（系统中存在多种需要用到的资源 -- cpu、磁盘、...   所以想要访问其他资源也需要排队 -- 不仅仅只有一个运行队列，即不只是存在一种队列！即等待其他资源提供所在的队列就是阻塞队列）	
	    比如使用scanf函数的时候，在运行的时候是不是用户没有输入的时候程序就不会进行下去。 -- 此时就是在等待键盘输入 -- 非cpu资源 -- 此时该进程状态就是阻塞状态。
	挂起：当内存不足的时候，OS通过适当的置换进程的代码和数据到磁盘，进程的状态就是挂起。
	    当内存块不足的时候，将长时间不执行的进程代码和数据换出到磁盘。这个磁盘专门有个分区：SWAP，但是只是临时的，在cpu内的信息即PCB即还是存在。
	退出（终止）	


    Linux下的进程状态：STAT   运行速度快    -- 理论的实践 -- 具体
	符号+ 前台进程 -- 即执行命令无效 ctrl c可以停止。（./可执行文件 & -- 后台执行 会返回pid）
	R 运行状态 -- 在运行队列或者正在调度（执行）
	S 休眠状态（阻塞状态、挂起状态） -- 大部分时间在外设资源等待上，运行代码的速度很快（cpu资源）
		-可中断睡眠
	D 睡眠状态，磁盘睡眠，深度睡眠 -- 不可以被中断，即不可被被动唤醒   
	（当服务器压力过大的时候，OS会通过一定的手段，杀掉一些休眠进程，来起节省空间的作用  -- 如果此时此进程如果在等待磁盘写入，被OS误删的话就会出现问题！为了防止出现这种情况，就会出现区别于普通睡眠的进程，即D--深度睡眠。此时只能等其自然醒来，或者关机甚至拔掉电源）
	    dd命令能够演示D状态进程
	T 暂停或者调试状态（t） -- 只是把代码停住了，并没有等待资源。-- 比如调试程序的时候打断点暂停实际上就是给调试程序进程打出了暂停信号。
	    比如发送kill - 19信号可以暂停   kill - 18信号可以再次启动
	Z 僵尸状态 一个进程已经退出了，但是不允许操作系统释放，处于一个被检测的状态。（当进程退出并且父进程（使用wait()系统调用）没有读取到子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入z状态） -- 一般是父进程和操作系统来进行检测    -- 长时间不释放 内存泄漏
	（维持该状态为了让父进程和操作系统来进行回收！  Z -> X）测试就可以使用创建子进程的方法，让子进程结束，父进程不结束，此时子进程就是一个僵尸进程（defunct -- 失效的）
	X dead终止 即释放进程需要一个一个来，需要回收其他的或者在忙其他的事情。瞬时性
	（pcb保留，代码和数据释放，pcb不再维护）

kill -n (n为每个数字代表的信号)

	孤儿进程：
		如果父进程率先退出，子进程就变成了孤儿进程。孤儿进程会被1号进程init领养（系统本身进程）--即父进程。
--此时注意ctrl c无法起作用
	为什么要被领养？没有父进程了，回收子进程资源就是需要父进程做的，父进程没有了，需要有人领养，才能回收。
	


进程优先级：
	为什么要有优先级：因为cpu是有限的，通过某种方式竞争资源
	什么是优先级：确认谁应该获得某种资源，谁后获得。

Linux下具体的优先级做法：

		（PRI）优先级 = 老的优先级 （PRI）+ nice（NI）
	（ps -l当前路径下运行线程 -la详细）
	pri就是进程的优先级： 值越小，越快执行
	（有很多调优先级的方法）
	top利用任务管理器修改 -r 输入PID
	然后就可以设置NI值，其范围为[-20, 19]超出范围到对应的断点取值
	如果系统只是让你往优先级低的调，可以使用sudo执行。
	注意：老的优先级是初始的优先级（80）--即每次设置优先级都要从进程最开始的优先级设置。
	
	但是可以发现只能调 60~99 所以cpu的调度不是让谁优先，而是尽量平均。



相关概念：
	独立性：多进程运行，需要独享各种资源，多进程运行期间互不干扰。（包括父子进程）
	竞争性：进程数目众多，cpu资源很少。便就有优先级，合理分配资源。
	并行：多个进程在*多个cpu分别同时进行运行。
	并发：
		时间片：给每个进程相对一定的时间进行使用cpu资源。时间一到选择下一个进程。
		抢占与出让：此时正在享用cpu资源并且时间片没有完但是此时来了更高优先级，那么就会发生抢占。	
	    即cpu执行一个进程在时间片或者抢占出让影响下，在一端时间内较为均衡的分配资源。
	    所以，在一个cpu下，多个进程在一段时间内同时得以推进。（一个时刻就是一个进程）

		线程切换：
		cpu内部有很多寄存器。如果此时一个进程正在运行，那么cpu内的寄存器--硬件（用户进程可显寄存器，系统内部不可显寄存器）一定保存此进程的临时数据。此临时数据就是该线程的上下文。此上下文数据绝对不能丢弃，一旦被丢弃，那么此线程就要被报废。
		那么此时如果时间片到了，或者被抢占要么出让，该进程没有运行完，那么此时进程就需要带走自己的上下文数据，暂时切下，等待下一次运行直接填充上下文数据继续执行上次中断的步骤。
		cpu内部寄存器存储的上下文只有一份，但是上下文可以有多份，分别对应不同的进程。
		


