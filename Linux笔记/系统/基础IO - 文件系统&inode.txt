文件系统：

引入：
	1.有没有被打开的文件，存在于磁盘（磁盘文件，打开的文件是内存文件）
	2.我们学习磁盘文件，测重点是？--这个文件在哪里？这个文件多大？这个文件的其他属性是什么？（单个文件角度）
				--一共有多少文件？各自属性在哪里？如何快速找到指定的文件？（系统文件角度）
			如何对磁盘文件进行分门别类的存储，用来更好的支持存取。
			--快递放在接收站时的编号，方便客户去寻找
	3.磁盘文件 - 了解磁盘：
		内存 - 掉电易失存储介
		磁盘 - 永久性存储介质 -SSD U盘 flash卡 光盘 磁带
		（磁盘是一个外设（在冯诺依曼结构中承担IO设备的）-- 还是计算机中唯一的一个机械设备） -- 会非常慢（相对） -> 操作系统会有一定的提速方式
	4.磁盘结构：
		磁盘盘片，磁头，伺服系统，音圈马达
		
		盘面上会存储数据 - 存储二进制 - 硬件上如何区分？（两态性） 磁铁-南极北极 -> 向磁盘写入 - 本质改变磁盘上的正负性								（一个一个非常小的）
	磁头去改变（来回读写） 物理结构&  -- 磁盘寻道的过程
	（磁头在盘片上悬浮的 - 如果挨着，那么数据会遭到破坏）
	磁盘的存储结构：
		必须要找到存储的数据必须在哪里 -- 必须要有规则 才可以找到数据 --存在一个一个同心圆 （磁道）以圆心为起点，往外延伸 -- 存在扇片
	扇区是磁盘存储的基本单位。物理上如何把数据写入指定的扇区去呢？ -- 如何找到一个扇区
							在哪一个面上 - 对应一个磁头
					面圈扇	CHS寻址	在哪一个磁道（柱面上 - 哪一个同心圆）
							在哪一个扇区上
					有了CHS 就能找到对应的扇区了。
		扇区的大小一般 512字节 4KB  --- 硬件上的要求
	磁盘的抽象结构（虚拟 逻辑）
		--利用磁带来进行理解
			存放在里面是一个圆形结构 -- 拖拽出来就可以变成一个线性结构 
			把卷起来的磁带 -- 想象成磁盘 -- 物理上是圆形结构 -- 想象的时候可以想象成线性结构
		想象完后，每一个单位是512字节。sector disk[1024*1024 * n] -- 数组！ 将来访问一个扇区，只需要知道数组的下标！LBA寻址 LB - 找到 CHS	操作系统访问磁盘就通过LBA去找到对应扇区的数据  [[[   ]扇区                   ]磁道                       ]磁盘	
		将数据存储到磁盘，逻辑上 将数据存储到该数据。找到磁盘特定扇区的位置 -> 找到数组特定的位置 对磁盘的管理 对数组的管理。


	拆分 -- 分区的过程 - 对磁盘的管理 -> 对一个小分区的管理（分区后管理方法一致）
	还大就继续分 --- 类比于国家管理 ：省 - 市 - 县 - 区.....每个分区管好，整个就管好了  ----- 分治思想
	Linux管理磁盘文件，是将文件内的属性和内容是分开管理的。
	每个分区开始 Bootblock（操作系统数据）   Blockgroup（块组 -重点）
		Superblock  GroupDescriptorTable BlockBitmap inodeBitmap inodeTable Datablocks
	 Superblock Linux文件系统属性信息 （整个分区的属性级）（可能会在未来的块组里进行备份 -- 防止数据破坏，让其恢复过来）	
	虽然磁盘的基本单位是扇区（512字节），但是操作系统（文件系统模块）和磁盘进行基本IO的单位是4kb（block） 8 * 512字节（哪怕是读写1比特的数据也是读取这么多 -- 为什么不以512字节为单位呢？1.512太小了，有可能会导致多次io 进而导致效率的降低  2.如果操作系统使用和磁盘一样的大小，万一磁盘的基本大小变了的话，操作系统的源码是否要改呢？--弱耦合 硬件和软件进行解耦）
	4KB - block大小 - 磁盘：块设备
	文件存储块：
	Data blocks ：多个4kb大小的集合， 报错的都是特定文件的内容（文件 = 属性 + 内容 - Linux存储的时候是分开存储的）
	inode Table：（ls -i  -- 查看编号 不同文件有不同的编号）inode一般是一个大小128字节的空间，保存是对应文件的属性，该块组内，所有文件的inode的集合，需要标识唯一性，每一个inode块，都需要一个inode编号 一个文件，一个inode，一个inode编号。
	管理块信息:（可以查看使用情况）
	BlockBitmap 假设有10000+个blocks，10000+比特位。：比特位和block（Data -- 每一个数据块）是一一对应的，标识此block 1标识被占用0标识可用
	
 	inodeBitmap 假设有10000+个inode节点，其中10000+比特位，其中同样也是一一对应的。标识同理
	1被占用 0可用
	
	块组描述符：
	  Group Descriptor Table 这个快组多大，已经使用多少了，有多少个inode 已经占用了多少 .... 一个块组的属性信息。

	把上面的弄清楚，能让一个文件的信息可追溯，可管理。
	块组分隔为上面那样，写入相关的管理数据 -- 文件系统信息 -> 整个分区被写入文件管理数据        格式化

	一个文件“只”对应一个inode属性节点，inode编号
	一个文件不可能只有一个block
		1.哪些block属于同一个文件？
		2.inode -- 找文件，找文件编号即可  -- （属性就能找到了 ）内容呢?  -- 根据block映射表，就能找到对应的块也就能找到文件数据了。
		struct inode
		{
			// 大小 inode编号 其他属性
			int blocks[n];  // 同一个块组的编号	
		}
	文件特别大如何？
	data block中，不是所有的data block只能存文件数据，也可以存其他块的快号	-- 通过这种间接的方式就可以将很多文件链接起来，这样就能存大量的数据。

	找到文件：indoe的编号->分区特定的bg->inode->属性->内容、
		如何知道indoe编号？
		linux中，inode的属性里面不存在文件名这一说法
	
	1.一个目录下，不存在同名的文件
	2.目录是文件，并且也有自己的inode 、data block	->文件名：inode编号的映射关系
		data block中存在文件名，inode。进入目录	创建文件（W）显示文件名与属性r
		-- 先找到目录结构，在找到映射关系拿到对应文件的inode--
	--依托于目录结构。才会知道inode编号。
	（但是注意目录也是一个文件，Linux一开始构建目录路径搜索树 - 支持目录搜索（路径缓存））


1.创建文件，操作系统做了什么？
	-找到对应目录所在分区和块组	inodebitmap遍历一个为0的比特位，修改为1表示占用->inodeTable--关于此文件的所有属性加入。Data blocks内容清空。
	必须建立文件名和inode映射。用户提供文件名，系统创建好后返回inode，此时在给目录（建立映射关系）。

2.删除文件
	
	找到对应目录的data block 根据文件名找到对应的inode编号，再由inodebitmap对应1置为0，blockbitmap 对应1置为0。在目录中将此映射关系清空即可--将文件置为无效即可。
	--能恢复，前提是曾经的inode属性 datablock没有被重复占用。
	
3.查看文件：
	目录-inode -属性，内容找到，拼接好，然后显示出


分区格式化--在磁盘写入文件系统	
																	inode是固定的，inodeTable也是固定的。




					
