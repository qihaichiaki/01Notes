定义：给操作系统一个指定运行的参数

例子：比如执行我的一个程序，必须带上路径，只写名字不能运行。但是系统程序（命令）可以不用带路径都能运行。
这就和环境变量有关。
which可以寻找命令所在路径。

初识：
系统命令可被默认找到 -- 储存到环境变量到路径的。
echo $PATH -- 查看环境变量
	每路径均以:作为分隔符，最后一个不带:

	不建议直接将自己的命令直接放入PATH上
	export PATH=$PATH:自己程序所在路径  设置一个新的环境变量
	export 导出环境变量 
	此时跑自己程序就可以直接写名字了，和命令一致
	此时随便搞，只要不改配置文件即可。退出重进可以复原。	

env 查看系统当中的环境变量 
$HOME -- 用户的主要工作目录


实际上main函数最多有三个参数：
int argc, char* argv[], char* env[] (环境变量指针的储存数组) -- 查看系统给此进程传递的环境变量；
同理，和env类似：   extern char** environ;和上面main函数传进的env类似。（c语言提供的全局变量）

当然，上述不方便，使用getenv("环境变量名"); -- PATH 即可。头文件 stdlib.h

任何一个程序（命令）环境变量均继承于其父进程 -- （单独一个父进程为bash -Linux下的命令解释器 ）

所有的环境变量都会被子进程继承。
bash的环境变量从操作系统来。




那么 argc、argv（字符数组指针）是什么呢？
命令行参数 第一个是传入的多少个选项 后面就是选项。
argv 
	此的重要意义：让同一个程序执行不同的子命令  所以命令行的指令
首先输入给bash
--所以 命令行参数也是继承的父进程






c、c++的存放区
进程地址空间：
高地址
		0xFFFFFFFF	
	栈区（地址向下增长）向下    -- 即地址数值越来越小
	
	堆区（地址向上增长）向上    -- 即地址数值越来越大
	未初始化全局数据区
	已初始化全局数据区
	代码区（静态区内置）
		0x00000000
低地址

但是不同操作系统测试出来的结果不相同	Linux编译正常 但是Windows不行，有可能会有其他的操作。
这里的进程地址空间 -- 不是内存

 