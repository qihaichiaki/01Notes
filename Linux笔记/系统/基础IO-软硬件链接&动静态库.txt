软链接
ln -s 前文件 后文件
硬链接
ln 前文件 后文件

后文件链接前者。
本质区别：有没有独立的inode。软链接有独立的inode->软链接是一个独立的文件。硬链接没有独立的inode，不是一个独立的文件。

软链接：特性：存在inode。可以理解软链接的文件内容，是指向文件对应的路径！
	
应用：相当于windows下的快捷方式

硬链接：没有独立的inode，不是真正的创建新文件。
特性：
	就是在指定的目录下建立文件名，和指定inode的映射关系。--起别名

	属性中存在一个数字，这个就是硬链接数。
		inode中存在count 引用计数 -- 默认为1。建立一次硬链接++，删除一次就--。删除文件不是将其inode删除，而是引用计数--，减为0的时候，才真正删除。

应用:
	unlink同样是删除命令。
	为什么文件目录默认引用计数为2？本身目录inode一次，文件内存在. ..两个文件。.对应的文件名就是本身目录的。
	本身文件名: inode
	. : inode

	dir - 2  == 内部目录个数（2位本身映射和.映射）




动态库-静态库
1.我想写一个库？（编写库角度）
	库里面不能有main函数
	
静态库 .a
	#include<time.h>
	time_t time(time_t *时区) 默认为null 返回一个时间戳、
	extern	声明全局
	vs命令可以打开另一个文件，使用vim
		-ww切换？
	
	gcc -c xxx xx.o  -- 链接
		如果只把.h和.o给别人，别人能用。gcc 最后将.o和头文件和main函数一起编译也是能用的。
		但是这样太多了。
	那么我们能否将这些.o文件进行打包呢?
		ar命令（归档文件） ar -rc(替换 创建) lib(前缀必须这样)名字.a(后缀必须这样) .o文件打包
	上述就是静态库的制作。
		查看静态库中的目录列表：ar -tv
			t:列出静态库中的文件
			v:verbose 详细信息
		
	makefile：
		libhello.a: .o文件
			ar -rc  libhello.a .o文件
		.o文件:
			gcc -c xxx -o .o文件
		.PHONY:文件夹
		文件夹名:
			mkdir ... /lib
			mkdir .../include
			cp -rf *.h include
			cp-rf *.o lib



库通常是给别人：include(库的头文件) -  lib是存在.o的文件

2.库给别人，别人是如何用的呢？（使用库的人的角度）
	静态库使用：
		头文件gcc的默认搜索路径是：/user/include
		云服务器库文件默认搜索路径：/lib64
	自己所写的库属于第三方库 -- 不是语言和操作系统自带的，C语言的默认静态库是libc.a编译C语言会默认链接。如果直接拷贝过去还是会链接不了，需要告诉GCC	gcc 目标程序.c -l库名(除开lib ,o)
	此时上述操作实际上就是所谓的库的安装。
	但是不建议直接安装在系统目录下。因为自己写的不一定通过考验。没有经过测试的库或者软件安装在系统下会有问题。
	删掉的过程就是卸载


	上述是第一个方法:
		硬使用此库：gcc main.c -I ./hello/include/  可以在给定的目录下寻找头文件 
		只不过此时也找不到库：gcc main.c -I ./hello/include/ -L ./hello/lib/	可以在指定目录下寻找库
	-l库名（千万别忘记这个，在目录下找可是有很多库的，必须要指明）
	 g++ -o test test.cpp -I ./include/ -L ./lib -lsort -std=c++11

	-I 头文件搜索路径（大写的i）
	-L 库文件搜索路径
	-l 指定库（小写l）



动态库 .so
动态库制作（静态库需要拷贝进行目标程序内部）
	同样的，首先将对应的源文件 编译为.o文件。只不过需要加上-fPIC （与位置无关的二进制文件  -- 位置即为进程的进程地址空间-静态库就是需要特定位置绝对位置。动态库不需要，相对找-偏移量）
	gcc -shared .o文件（与位置无关） -o lib名字.so  // 制作动态库

makefile进行规整化-文件 include存放.h头文件 lib存放动静态库
	gcc main.c -I ./hello/include/ -L ./hello/lib/ -l库名
	1.如果此时库名是由动静两库，会优先链接动态库。
		ldd 可以查看程序的链接
		gcc如果只有静态库，目标可执行是将静态库拷贝链接进目标程序里，其余该动态链接的就动态链接
		
	2.如果只有静态库，只能使用静态库
	3.指明-static 强制使用静态库 （摒弃优先使用动态库的原则，直接使用静态库）
	但是只是运行上面，动态库会报错。
	4.要使用动态库链接，需要把动态库加载入内存：上述是给gcc说的。运行加载和gcc无关（只是链接了）。所以运行加载时要告诉操作系统加载器ld，加载入内存。
		1. 拷贝到系统路径下：不推荐
		2.export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:绝对路径（到库路径下）
			此时在运行就可以找到对应的动态库了
			-- 缺点，命令行只是一个暂时性，一退出就没有了。
		3.修改配置文件：
			创建 /etc/ld.so.conf.d/名字.conf
			将动态库路径放入此路径即可。
			ldconfig  -- 配置文件生效一下
		4.sudo ln -s 绝对路径库路径 对应的系统路径  -- 建立一个软链接

					

---------------------动态库的加载-------------------
task_struct	地址空间		页表		内存				磁盘
		......				程序内存
		栈		建立联系		库内存
		共享区 -- （动态链接 页表去链接）相对地址（起始地址+偏移量就可以找到库中的函数）
		堆
		代码区（静态库会在里面）					a.out  libhello.so

	动态库是一个独立的库文件
	动态库可以和可执行程序分批加载***
		这样库文件就可以被很多进程使用
		

	
为什么要有库？？？
	库的存在，可以大大减少开发周期，减少开发周期、提高软件本身的质量
	站在写库的角度:1.简单 2.代码安全

好玩的库：1.ncurses-字符的界面库  2.boost  准标准库：	

每一个动态库被加载到内存，映射到进程的地址空间，映射的位置可能是不一样的，但是因为库里面的是相对地址，每一个函数定为采用的是偏移量的方式找

共享区 - 动态库链接
