gcc 只能用来编译c语言
g++可以编译c语言，也可以编译c++
	gcc/g++ -v查看版本
sudo yum install -y gcc-c++ 安装
	c和c++程序翻译的过程
推荐编译c代码：gcc c文件 -o 目标文件名 生成目标文件可执行
*-o 后跟着的是形成的目标的文件名
（gcc这样就是默认一步到位）
下面是分步进行：-ESc 电脑的左上角（记忆）   形成目标文件：iso
    1.预处理：gcc -E c程序 -o c程序名.i -->（不加o的话默认输出到屏幕上，即将预处理后的文件写入.i文件内）
-E(进行程序的翻译，预处理工作做完就停下来)
	1.头文件会拷贝在源文件下 2.宏替换 3.注释和条件编译该去掉的就去掉了。
预处理之后依然是c语言  -.i

    2.编译：（c->汇编语言）gcc -S c文件名/预处理之后的文件名 -o 文件名.s（和上面同理，将汇编后的文件写入.s文件内）
-S进行程序的翻译，编译工作做完就停下来)

    3.汇编：（汇编->2进制文件）gcc -c c文件名/编译后的文件 -o 文件名.o（可重定位目标文件）(和上面同理，将反编译成二进制文件的写入.o文件内)
-c(进行程序的翻译，汇编工作做完就停下来)
	此时.o文件不可被运行

    4.链接：gcc c文件/2进制文件 -o 目标文件名
无需带任何选项



动静态库：（感性的理解）
file 查看是多少位的可执行程序
ldd 查看可执行程序的命令  查看依赖的动态库

一般链接的过程，是有两种方式：1.动态链接-动态库，2.静态链接-需要静态库

头文件找到声明--再去库找代码的实现--然后和自己代码关联-->
（方法列表）         
 源文件包含头文件 链接库形成可执行文件

Linux:        .so 动态库  .a   静态库
windows:  .dll 动态库  .lib 静态库

--c程序，是脱离不开库的
--Linux的许多指令也是c语言写的

动态链接（.so） 库的方法地址填入可执行程序中，建立关联，链接就要去库里找。优点：节约资源 缺点：需要依赖库
静态链接（.a）   库的方法的实现直接拷贝到可执行程序中。优点：不依赖库 缺点：浪费资源
gcc、g++默认形成的可执行文件使用动态链接.so 使用lld和file  （基本是所以编译器默认的）
*-static选项 -- 形成静态链接的可执行文件 在末尾加即可
但是可能没有静态库导致链接失败
	sudo yum install -y glibc-static c静态库
	sudo yum install -y libstdc++-static c++静态库




维护项目结构 ：自动化的构建项目
make makefile
make是一个命令：
makefile是一个文件（首字母可以大写）

编写makefile（a、依赖关系  b、依赖方法） -->管理项目
mytest:c源文件名 -- 依赖关系
[tab]gcc 命令   -- 依赖方法
	
.PHONY:clean(位目标) //伪目标，直接执行方法的
clean:                  --关系
[tab] rm -f ..        --方法

make运行（只运行第一个默认关系 从上到下） 
后面加 空格加clean就执行清理
即 后面接上关系名（目标名）就执行对应方法。
.PHONY：clean  --伪目标 总是被执行（即每次输入其目标 必须生成，而不需要说明）
习惯：给clean设置.PHONY：

那么，不加伪目标，make是如何识别程序是比较新的呢？
--根据源文件的最新修改时间ACM（stat可查看）和可执行程序文件修改时间做比较
Access：读取时间（由于此操作比较高频，累计到一定时间会修改）  Modeif:内容改变时间 Change：属性（权限、大小）

编译项目的时候：
需要编译的是.c文件 (预处理后.h文件就不考虑了)
mytest:test.o main.o --依赖文件
[tab]gcc - o mytest test.o main.o 链接
test.o:test.c
[tab]gcc - c  编译
main.o:main.c
[tab] gcc - c
.PHONY:clean
clean:
[tab]rm 



注意，c语言默认从上到下执行的。但是如果printf("111");sleep(n);（秒） 看起来会先执行sleep，然后才会显示。--实际上从上到下是没有问题的，printf先执行出来了，但是c语言会给我们提供输出缓冲区的，根据特定的刷新策略，来进行刷新。
c语言提供的一段内容空间 
*显示器设备，一般的刷新策略是行刷新 碰到\n,就把\n之前的所有字符全部会给我显示出来 
c语言会默认打开三个接口：stdin,stdout,stderr  -- 文件类型
fflush(stdout);//数据写到缓冲区内的，立马释放出来

回车 -- 换行
换行，当前位置上下*平移。
回车 回到当前行最开始位置
所以很多换行实际上就是 回车换行
所以键盘上的enter可以看的出来先下在最左
语言中的就是\n(回车换行)    回车的话就是\r

所以倒计时程序就可以利用这个制作。（\r fflush）
进度条也可以这么制作 
usleep(n)（微秒）
c语言里面显示% -- %%
预留空间默认从右到左跑  此时c语言格式化控制%后加-


