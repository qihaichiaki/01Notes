信号
-------------------------------------
思路：
	产生前-信号发送中-信号处理&&处理完成

	信号产生		信号保存		信号处理
	ab		c		d
注意：信号和信号量是两个东西，没有关系！

A.什么是信号
-----------------
生活中的信号：红绿灯、闹钟
	你为什么认识这些信号呢？记住了对应场景下的信号 + 后续是有"动作"需要执行的。->我们能够识别这个信号
	我们在我们的大脑中是能够去识别的。
	如果特定信号没有产生，但是我们依旧知道如何处理此信号。
	我在收到此信号的时候，可能不会立即处理此信号。
	信号本身在我们没法立即处理的时候，也需要先被临时记住。

1.那么什么是Linux信号？
本质是一种*通知机制，*用户或者是*操作系统通过发送一定的信号，通知*进程某些事件已经发送，可以在后续进行*处理。

2.结合进程，信号结论
a.进程要处理信号，必须具备信号"识别"的能力（认识 + 处理）
b.进程识别信号-程序员编写代码
c.信号的产生是随机的，进程可能正在处理事情，所以，信号的后续处理，可能不是立刻进行处理的
d.进程会临时的记录下对应的信号，方便后续进行处理
e.合适的时候进行处理
结论：信号的产生相对于进程而言是异步（不等它，也就是自己做自己的，互相不干扰）的。

3.信号如何产生的？
	比如ctrl + c ->可以直接终止前台进程。实际上通过键盘组合键向目标进程发送2号信号。  kill -2 pid
	ps -ef |.... -查看进程信息
	
	信号处理的常见方式：
		a.默认（每个信号的默认处理动作，进程自带的（程序员写好的逻辑））
		b.忽略（也是信号的处理一种方式）
		c.自定义动作（捕捉信号）
		

4.常见的信号：
	kill -l（查看系统默认信号 大概62个信号）
	1~31信号：普通信号[1, 31]
	后面的带了RT的信号是实时信号。[34, 64] （分时操作系统（时间片）和实时操作系统（严格的时序-特殊的行业，即遇到信号必须立即响应 比如一些车载系统） ）
	1挂起 2中断 3......
	man 7 signal - 查看特定信号的详细描述
		action 默认动作 Term、core 终止的一种。  --大部分的信号的默认动作都是终止。

如何理解组合键变成信号呢？
键盘的工作方式是通过中断方式进行的。当然也能够识别组合键。ctrl+c 
OS解释组合键-> 查找进程列表->前台运行的进程->OS写入对应的信号到进程的内部的位图结构中


如何理解信号被进程保存呢？
a.什么信号？
b.是否产生？
进程必须具有保存信号的相关数据结构。（位图结构 unisgned int, ）
0000 0100  比如此时6号信号产生。其余信号都没产生。
	进程的PCB保存了信号位图字段。


如何理解信号发送的本质？
	信号位图是在task_struct 维护起来的->内核数据结构->操作系统有权修改
	信号发送的本质是操作系统向目标进程写信号。OS直接修改对应PCB中的指定的位图结构，完成发送信号的过程。
		


-----------------
*B.信号的产生：
-核心转储：
	wait输出参数中后八位的第一位比特位存储的就是core、dump标志 - 是否发生核心转储
	一般而言，云服务器（生产环境）的核心转储功能是被关闭的！
		（企业投放到市面上供用户使用-称为生产环境）

	信号的默认处理动作：
	term 终止
	core 核心转储 也有终止
	.....
	
	ulimit -a 查看一些基本的配置
	ulimit -c 10240 ... 设置核心转储。临时的。
	发生条件：
	-如果发送信号存在core，会生成core.进程号的文件。
	du 统计文件大小

	概念：
	-当进程出现某种异常的时候，是否由OS将当前进程在内存中的相关核心数据，转存到磁盘中去。
		主要是为了调试。
	-如何进行调试？
		ed：8号信号就是对应的除零错误。
		调试的时候注意编译加-g 进行开发模式。
		od 二进制打开文件。
		打开gdb调试文件。
		gdb core-file core文件 会自动定位错误地方。
			--应用场景

-验证进程等待中的core dump标记位：
	是否发生核心转储。即是否真的dump到磁盘中。

-为什么生产环境一般关闭core dump?
	频繁生成，磁盘会塞满 - 影响操作系统。 

-信号处理的方式：1.默认 2.忽略 3.自定义捕捉
			自定义捕捉：
				man signal -> 对特定的信号进行捕捉	
				1signum参数：哪个信号进行捕捉 2handler参数 函数指针  3sighandler_t(void (int))返回值-函数指针返回的是老的方法。（即默认方法 - 默认0，忽略1）	
				（回调函数，通过回调的方式，修改对应的信号捕捉方法。）
				1参数推荐写对应的宏。2函数指针必须是void (int)
					函数里的int实际就是接收信号的编号的。void catchSig(int signum)
				注意signal函数仅仅是修改特定信号的后续处理动作，不是直接调用对应的处理动作。如果后续没有任何sigint信号产生，回调函数里设置对应的函数就不会被调用。

				提出问题：
					如果信号全部被捕捉，进程是否不会被别人干扰？		

			特定信号的处理动作，一般只有一个。被捕捉了就不可能被忽略。

-产生信号：
	a键盘产生。
		ctrl \ ->发送3号信号
		kill -2 pid 也可以进行验证。
		ctrl c -> 发送2号信号
	
		
	b系统接口发送信号。
		man 2 kill
		kill(pid, sig);
			可以利用命令行参数进行测试。
		

		man 3 raise
		rause(int sig);  -- 向自己进程发送信号。
		
		man 3 abort（C语言级别接口）
		abort(void);  自己终止自己。 -通常进行终止进程 -core
			对应的就是6号信号	

		如何理解？
			用户调用系统接口->执行OS对应的系统调用代码->OS提取参数，或者设置特定的数值->OS向目标进程写信号->修改后进程后续处理信号->执行对应处理动作。
	
	c软件条件产生信号：
		管道，读端不读，而且关闭了读端。写端一直在写，会发生什么问题？此时写就不存在意义了。OS会自动终止对应的写端进程，通过发送信号的方式，SIGPIPE！-13号信号
		验证：1创建匿名管道2让父进程进行读取，子进程写入。3.父子可以通信一段时间4.父进程关闭读端。父进程等待子进程。子进程仍然写即可。5.子进程退出检测退出信号即可。
		-软件条件不满足，操作系统检测到直接发送信号进行终止异常。

		alarm -设置闹钟 alarm(秒) 14信号 一旦触发就会自动移出了。
		// 可以验证1s内cpu的count++
		// 为什么我们只验证到1w+左右呢？-原因就是cout+网络发送 = IO。
		// 如果单纯的想计算算力呢？
		singnal(SIGALRM, 设置函数)  -- 计算算力
			周期性的检测就可以在设置函数里在设置一个闹钟即可。
		// 可以用简单的闹钟-> 设置了一个定时器的功能。
			io的效率其实非常低，尤其带上网络。
		
		如何理解软件条件给进程发送信号：
			OS先识别某种软件条件触发或者不满足 OS构建信号，发送给指定的进程。
			
	d.硬件异常产生信号：
		ed：/0异常，但是如果条件在前面，后面是循环，但是接收信号会存在死循环。
		如何理解除0呢？
			1.进行计算的是CPU，这个硬件
			2.CPU内部是有寄存器的，状态寄存器（位图），有对应的状态标记位，OS会自动进行计算完毕之后的检测。如果溢出标记位是1，操作系统立马识别到有溢出问题。立即只要找到当前是谁在运行提取PID，OS完成信号的发送，进程会在合适的时候，进行处理。
			3.一旦出现硬件异常，进程一定会退出吗？不一定，默认是退出。但是我们即便不退出，也做不了什么。（一般打一条错误消息在退出）
			4.为什么会死循环呢？寄存器中的异常一直都没有解决。->终止。
		
		段错误：11号信号
		野指针使用，越位这些->
			同理，也会死循环

		如何理解野指针或者越界问题？
			1.都必须通过地址，找到目标位置
			2.语言上面的地址都是虚拟地址。
			3.将虚拟地址转化为物理地址。
			4.页表+MMU(Memory Manager Unit, 内存管理单元-硬件！)
			5.野指针，越界-> 非法地址 ->MMU转化的时候一定会报错。
			（计算机里不要认为只有CPU存在寄存器，几乎所有的外设和常见的硬件都存在寄存器）

所有的信号，都有他的来源，但是最终都是被OS识别，解释发送的。
------------------------------------------

时钟中断-操作系统执行流
cpu主频 -越高，时钟中断频率越高，操作系统响应周期越快。

-----------------------------------------
C.信号的保存
--------
-阻塞信号
	信号其他概念：
		实际处理信号的处理动作称作信号递达Delivery
		信号从产生到递达之间的状态叫做信号未决Pending	在未来合适的时候进行递达。
			-进程是不是可以不对一些信号进行递达呢？可以选择性的进行屏蔽。
		进程是可以阻塞(Block)某些信号的。
		注意阻塞和忽略是不同的。信号被阻塞就不会被递达。但是忽略是递达之后可选的一种处理动作。
			-忽略是属于已经递达了，但是动作是忽略，阻塞是不会进行递达的。
		如果信号的阻塞状态被解除了，那么就可以被递达。

	内核中的表现：
		进程PCB内部存在三张信号表。
		信号屏蔽字
		阻塞		未决			递达
		Block表  位图表  	Pending表 位图表		handler表
		（结构和		（代表是否收到信号		（typedef (*handler_t)(int);
pending类似，代表对应的信号		收到就是1，否则为0）	函数指针数组，数组下标就是对应信号的编号)
是否被阻塞。）

		-默认，忽略，自定义如何理解？
			自定义就是signal函数传入的函数指针，其次SIG_IGN 1 忽略   SIG_DFL 0 默认
		
		进行递达的时候，操作系统首先识别信号编号，然后通过handler表找到对应的函数指针 ，然后先进行强转看是否等于0，等于0就执行默认动作，如果不是在判断是否等于1，就完成忽略。如果都不满足，那么就是调用对应的自定义方法。
		

	一个信号被处理，OS是如何进行处理的呢？
		发送信号。（OS修改pending位图）
		处理信号。（遍历pending位图，找到收到信号查看block，如果为1则不做处理，为0就进行递达处理）
		pending -> block -> handler
			干涉信号产生的动作

	结构决定算法。
	

接口学习：
	sigset_t 操作系统提供的一种位图类型。（不同的系统可能存在差别）信号集
		--不允许用户自己进行位操作。OS给我们提供了对应操作位图的方法。
		--用户是可以直接使用该类型的和用内置类型或者自定义类型完全一致。
		--一定需要对应的系统接口来完成对应的功能，其中系统接口需要的参数就包含了sigset_t 定义的变量或者对象。
	本身操作位图接口：
	#include <signal.h>
	int sigemptyset(sigset_t *set); 
		初始化set所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含 任何有效信号。
	int sigfillset(sigset_t *set);
		初始化set所指向的信号集,使其中所有信号的对应bit置位,表示 该信号集的有效信号包括系统支持的所有信号。
	int sigaddset (sigset_t *set, int signo);//添加信号位
	int sigdelset(sigset_t *set, int signo);// 删除信号位
	int sigismember（const sigset_t *set, int signo);  //检测
		注意,在使用sigset_ t类型的变量之前,一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的状态。初始化sigset_t变量之后就可以在调用sigaddset和sigdelset在该信号集中添加或删除某种有效信号。
		这四个函数都是成功返回0,出错返回-1。sigismember是一个布尔函数,用于判断一个信号集的有效信号中是否包含某种 信号,若包含则返回1,不包含则返回0,出错返回-1。


	int sigpending (sigset_t *set) 通过该函数获取当前调用进程的pending信号集。
		成功0，失败-1

	int sigprocmask(int how, const sigset_t *set, sigset_t *oldset) 对block表进行修改
		how 新增，去除，将set设置为新的block
			set包含了希望添加到当前信号屏蔽字的信号
			.....
		成功0 失败-1

		oldset 输出型参数：将老的信号屏蔽字set输出出来。
		

代码操作：
	1.如果对所有的信号都进行了自定义捕捉，那么是不是就存在一个不会被异常或者用户杀掉的进程吗？
	2.如果将2号信号block，并且不断的获取并且获取当前进程的pengding信号集，我们突然发送一个2号信号，我们就可以看到对应信号0->1......
	3.如果我们对所有信号进行阻塞（block）--是不是也是不可被杀掉呢？
	
		
	//1
		for循环，自定义进行捕捉即可 1 ~ 31全部捕捉 signal
		并不是的，操作系统的设计者已经考虑了。9号信号是不可被捕捉的。-> 管理员信号，无法自定义捕捉
		
	//2 3
		// 捕捉2号信号
		signal(2, handler);

		sigset_t bset, obset;  // 定义信号集对象。
		sigset_t pending;  // 可初始化或者不可，因为每次都是覆盖
		sigemptyse(&bset);  // 初始化

		// 添加要屏蔽的信号 
		sigaddset(&bset, 2);
		
		int n = sigprocmask(SIG_BLOCK, &bset, &obset);  // 设置到内核
		assert(n==0);
		(void)n;  // 防止rel版本下变量未用报警

		cout << "block 2号信号成功" << endl;
		// 默认进程不会对任何信号进行block
		
		// 重复打印当前进程的pengding信号集。
		int count = 0;
		while(true)
		{
			// 获取当前进程的pengding信号集
			sigpending(&pending);
			// 显示pengding信号集中没有被递达的信号。
			static 自己接口{
				for (1 ~ 31)
				{
					if (sigismember(&pending, i)) cout << "1"
					else "0";
				}
				cout << endl;
			}
			sleep(1);
			count++;
			if (count == 20)
			{
				int n = sigprocmask(SIG_BLOCK, &obset, null);  // 设置到内核
				assert(n==0);
				(void)n;  // 防止rel版本下变量未用报警
				//恢复对2号信号的block 但是默认情况下恢复的话会执行默认方法，没有进行捕捉
				
			}
		}
		
		发现：
			打印解除block和捕捉的顺序，是一个打印的问题
			貌似没有一个接口用来设置pending位图（所有的信号发送都是修改pending位图的过程），我们是可以获取的sigpending。

			9号信号不可被捕捉或者阻塞
			19 不可被阻塞
			20 忽略？
			

---
基本上，语言会提供.h .hpp 语言的自定义类型，同时，OS也会给我们提供.h和OS自定义的类型。
语言调用外设，一定会调用系统调用。在语言层的头文件内一定也包含的有OS相关的头文件。

------------------------
D.处理信号
------
	信号产生后，信号可能无法被立即处理
	1.在合适的时候（是什么？）
		pending->block->handler
		信号相关的数据字段都是在进程内部的。（进程PCB内部的-内核范畴）内核状态  用户态
							处理信号必须转化为内核状态进行处理
		在内核态中，从内核态返回用户态的时候进行信号检测处理！为什么会进入内核态呢？
			进行系统调用的时候，或者缺陷，陷阱，异常，进程切换也都有可能进入
				汇编指令 int 80 -> 由用户态变为内核态   系统调用一开始汇编就会包含。

		user	用户态	是一个受管控的状态（访问权限的约束，资源限制）
		

		kernel	内核态	是一个操作系统执行自己代码的一个状态。具备非常高的优先级。

-----------------------------------------------------------------				
cpu	进程地址空间（0~3G - 用户地址空间 3~4G内核地址空间）			物理内存（OS只有一份）
						内核级页表（被所有进程所共享，映射到OS）
							页表
						（用户级页表-每个进程都有并且不一样）

------------------------------------------------------------------
		每一个进程都有3~4G的地址空间，是给内核使用的，内核如何进行使用？
		内核也是在所有进程的地址空间上下文中跑的。
		可以执行进程切换的代码吗？当然可以。
		为什么能够执行OS的代码呢？凭借的是我们是处于内核态还是用户态。CPU内的寄存器实际上存在两套，一套是可见的，另一套是自用的（硬件上就可以专门区分执行用户态还是内核态）。CR3寄存器表示当前CPU的执行权限。int 80 修改
		所有的软硬件资源都可以随时访问操作系统资源。->和访问库函数类似的，只不过有相关权限和身份的验证。执行系统调用的时候，身份就会转换。
		
			
	用户态到内核态 为什么？
		一些功能，用户态无法执行。（操作系统是软硬件资源的管理者）调用系统接口，或者时钟中断去调用内核代码。
	内核态到用户态：
		1当前用户代码没执行完 2用户若干的进程并没有被调度。

	什么时候处理：
		内核->用户态 进行信号检测和处理
			返回时，内核的功能已经做完了。保证，操作系统的行为优先执行。
	2.信号处理的整个流程
		1执行主程序流程的某条指令，因为中断，异常或者系统调用进行内核（没有会因为时间片到了，也会陷入内核）2内核处理完，准备回用户模式之前先处理进程中可递达的信号 pengding->block->handler3.（忽略-pengding直接修改为0，终止-PCB释放等等，就不用返回用户态了 core-核心转储 io操作即可 stop-PCB进程的状态修改为t状态即可-放入等待队列中-cpu调度算法）捕捉状态：如果信号的处理动作自定义的信号处理函数回到用户模式执行信号处理（而不是回到主控制流程）

		-我当前是什么状态？kernel-内核状态
		-我当前状态能不能执行？1能 但是不想。
			因为如果此自定义函数中包含非法操作-rm scp... 此时是内核态那么就会被别人盗取。操作系统不相信任何人--提供更好的服务。所以就不能用内核态执行用户的代码
	

		4.信号处理函数返回时执行特殊的系统调用再次进入内核 5.（修改位图等操作）返回用户模式从主控制流程中上次被中断的地方继续向下执行。
			atexit->系统终止也会返回用户态执行特定的方法

		记忆方法：无穷大 （主要是自定义信号捕捉函数）
		中间的焦点：kernel信号检测。从中偏上拉一根横线，向上是user 向下是kernel 横线有四个焦点 分别就是切换状态。

	3.信号的操作：
		signal(int, void(*)(int*));  基本的信号捕捉方法
		int sigaction();-> 也是信号捕捉的方法，但是操作会复杂一点，功能比较强大。
			sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
			sigaction act 输入型参数	oldact输出型参数
		成功0，失败-1

		struct sigaction  操作系统定义的结构体类型
			void (*sa_handler)(int);-- 信号捕捉回调函数
			实时信号和其余的不考虑
			sigset_t sa_mask;
			sa_flags;  // 标记位先设置为0，不管
			（5个字段三个不谈）
		代码操作：
			可以先利用sigaction捕捉2号信号。利用sigaction结构体进行操作
			还可以将原本的默认方法提取出来，强转一下即可。默认0 忽略1
		
		-处理信号的时候，执行自定义动作，如果处理信号期间，又来了同样的信号，OS如何处理？
			在任何时刻，只能处理一层信号。
		本质：为什么要有block？
			当某个信号处理函数被调用时，内核会自动将当前信号加入进程的信号屏蔽字。直到处理结束为止。除了当前信号外，还想屏蔽其他额外的信号，就可以设置sa_mask。
			在自定义处理信号中休息10s，此时就可以验证上述结果。
			1-默认处理期间对当前信号进行屏蔽。-利用打印pengding函数：0 -> 1 的过程
			2-利用sa_mask 对34567进行屏蔽 然后测试
			
		



---------------------------------------------------------------
pidof 进程名 - 可以直接拿到pid


i=1; id=$(pidof mysignal); while [ $i -le 31 ]; do echo kill -$i $id; let i++;sleep 1; done
.sh脚本文件
	bash 脚本文件
	
--------------------------------------------------
补充知识点：
	信号捕捉，并没有创建新的进程或者线程。
	可重入函数：
		场景：
		struct node
		{
			struct node* next;
			(T)(void*) (int) data;
		}

		头插：head = n1  插入n2
		n2->next = head;
		head = n2;
		因为时序（进程调度时序的变化）导致内存泄漏的问题 -- 非常不好被排查。
		根本问题：不同的执行流执行同一种方法（main执行流和信号执行流）->函数被重入了。
		函数在特定时间段内，被多种执行流重入。->没有问题：可重入函数。存在问题：不可重入函数。
	

		可重入函数和不可重入函数：
			是函数的一种特征。目前我们用的90%以上的函数，都是不可重入的。
	
		特征：函数用了全局数据，传入一个数据... new malloc STL容器 不可被重入。


	volatile：关键字
		场景描述：
		
		int flag = 0;
		
		void changeFlag(int)
		{
			cout << flag;
			flag = 1;
			cout << "->" << flag << endl;
		}
		int main()
		{
			signal(2, changeFlag);
			while(!flag);
			cout << "进程正常退出后: " << flag << endl;
		}
		
		上述场景是GCC - G++   -编译器有时候会自动的进行代码优化。
		GCC、G++ 加入优化选项的话man GCC -O1 正常情况下 O1优化级别 O3优化级别最高
			优化后，上述代码就结束不了。
	cpu		
	寄存器		代码片段（进程地址空间）  内存（flag = 0）
	（edx）
	（读取数据，改为1返回即可 -- 正常情况下）
	（但是编译器优化-自作聪明：在主程序流没有修改flag的操作，所以在主执行流就将flag放入edx中，就不会访问内存中存在的flag了。所以此时尽管你任意修改flag也不会退出。）
	-> 让cpu无法看到内存 - 内存被遮盖了 - 
	-> 有一些有可能被优化的子段，需要程序员提醒，编译的代码必须保存内存的可见性。-volatile就可以起到作用了。	


	优化的时机？编译的时候就已经优化好了。
		


	SIGCHLD信号-
		进程等待的时候，父进程如果不等待：僵尸进程+父进程无法得知子进程的执行结果。
		实际上，子进程在退出的时候，会主动向父进程发送SIGCHLD 17号信号。		
		但是17号信号实际上默认的动作是忽略 Ign（应用层什么都不做 内核层：存在一定作为）Child stopped or stop- 只有Linux采用了这样的方案。
		-基于信号的子进程回收。
		
		
		1.捕捉17号信号，子进程退出进行捕捉即可。
		2.在捕捉函数里进行回收 while(wait()); // 10 5个子进程退出？如果同时-严格意义上 那么就会丢失-panding表只能存在一个 -除非是实时信号  while循环使用非阻塞
		3.如果我们不想等待子进程，还想不让其变成僵尸进程：
			signal(SIGCHLD, SIG_IGN);//手动忽略
		// 但是默认的处理不就是IGN吗？为什么默认不可以，但是手动设置就可以回收僵尸状态呢？
			// 操作系统的忽略：该什么状态就是什么状态  用户忽略：真忽略，并且还要回收。








拷贝到目标机器
scp 文件 身份@主机ip:目标路径