shell运行原理  -- 外壳程序


计算机结构：
"人"（‘人’不善于直接使用操作系统；如果让人直接访问操作系统，操作成本特别高，另外，人会犯错，会带来不安全因素）
shell 外壳程序（人 给外壳  外壳给操作系统）
操作系统（向下管理好软硬件，向上提供给用户良好的操作环境）
硬件驱动
硬件

所以，系统设计者，不会让人直接操作操作系统。
所以，我们使用者如何访问操作系统？那么图形化界面和指令操作是什么东西呢？	我们是利用中介来进行操作系统
	操作系统提供的外壳程序访问  命名行解释器
	*外壳程序的意义：1.是用户和操作系统中间软件层	2.可以在一定程度，起到保护操作系统的作用
	$BASH  （echo $BASH   查看外壳程序所在的文件）bash和shell均是外壳但是bash是具体的，shell可以说是bash这一类外壳程序的统称。Windows外壳程序也可以叫shell，但是LInux cen..使用的具体外壳是bash





权限：
对人操作：
	root: 只有一个，具有Linux下的最高权限

	普通用户:可以有多个，要受权限的约束(需要在root权限下  useradd新建用户 passwd 用户名 修改密码)

	但是对于Linux来说，无论root和普通用户可以同时存在多个用户，多用户操作系统。

root <------------> 普通用户（切换权限） 用户如何进行身份切换？（不建议root和普通用户密码一致）
su - 回车   ---->root密码 whoami  如果不跟也是root
su 用户名 （如果是root，可以随便变成任何人，但是看不到密码，但是能改密码）
但是如果是普通用户切换成其他用户，此时需要输入密码，那么就要输入此用户的密码


对角色和文件操作：
权限是什么？针对人的，事物的基本属性决定权限相关的概念  --->  文件 --> 一件事情是否允许被你"做"（读和写）
*权限的核心 = 人 + 事物属性

认识一下Linux下的文件的权限：
ll下的可以展示文件属性：  开头 10个字符 
第一列第一个字符，表示该文件类型，Linux下不以文件的后缀来区分文件的类型（Windows下是这样的）
扩展：vim  wq写完保存     gcc编译c文件    ./运行
（*重点）
*d：目录
*-：普通文件
p：管道文件 
b：块设备 （典型的是磁盘设备）
c：字符设备 （典型的是键盘或者显示器）
l：链接文件（类似于Windows的快捷方式）
.....

Linux下不以文件后缀区分文件类型，不代表不可以使用（在系统层面没意义，给自己看的）。
但是，需要注意的是，只是Linux不区分后缀，但是在此系统下的软件就不一定了
比如gcc就需要.c后缀的文件了

人：可以认为是一种角色，或者身份root或者普通用户均可
拥有者（owner）：文件属于谁     （ll下人名的第一个名）

所属组（grp）：文件属于哪一个组（第二个人名 可以自成一组）

other：不属于上面的任何一个 （不会记录，因为上面的记录了，只要不是就是other）

那么，如何理解所属组呢？特定文件进行组内管理



事物属性：
第一个字符是类型
后面的九个字符 3个为一组，分别和拥有者 所属组 other
一组权限对应三个字符 rwx 三个位置有就是对应字符，没有就是-       *读  写 可执行  必须是这个位置



所以改变权限就是从两处出发：
**改变属性：
1.ugo+-	rwx
chmod：（不一定能执行，只是有权限）拥有者 u+x  给其加上权限     u -rw 减去rw   u+r,u-x   
拥有者u  所属组g other o   使用,可以继续执行      a表示所有人
2. 换成2进制  111(rwx)  --- 切换成 八进制  即，利用八进制数字进行修改
chmod 777   chmod  000  chmod ....


**更改文件的ug（owner grp）
chown：修改 拥有者
chgrp：修改 所属组
但是，一般系统不允许  只能强制给  利用root权限

除此之外，可以利用sudo chown ....  然后输入本普通用户的密码，就可以修改
（sudo即就表示以root级别来执行）
但是 一般不能用sudo 需要添加到信任列表里，才可以执行sudo。添加到信任列表是需要root权限的。

也可以一次性修改了  chown  名字:名字 文件名

没有权限就禁止访问

*但是，root不受上述权限的影响。
因为，规则就是我定的，我随意进入。




常见的权限问题：
rwd
（首先，如果本人是拥有者，那么人的权限就是拥有者，如果同时也是所属组，那么只看一个拥有者）
1.目录权限：
进入一个目录需要什么权限呢？（执行一个过程）
	需要x权限
那么rw限制了目录的什么呢？
	r  查看该目录下所有文件
	w 在该目录下创建文件

2.umask
Linux一个目录被创建，默认起始条件是  777  		--  775rwxrwxr-x
普通文件被创建，默认是666  		-- 664 rw-rw-r--
最终权限 = 起始权限 & (~umask)（权限掩码）（凡是umask出现的权限 都不应该在最终权限出现）
	*umask是linux下设置文件默认创建权限掩码， 文件给定权限与掩码取反相与得到实际权限

设置权限掩码：umask 0权限（八进制3位数）



3.粘滞位（了解）
删除这个文件是这个文件所属的目录说了算
	如果大家所有用户都在一个共同的路径下，对该目录具有读写执行权限，均可删除别人的文件（所在的目录other的w权限）
	但是一旦这个禁用，均不能删除创建了，也就是说用户自己都不能操作自己了。
现在要求能共享 能新建删除，不能删除别人--粘滞位。
chmod +t 共享文件名（此时other的最后一个x变成了t）	这样，别人就不能删别人的了（root除外）
注意：此t只能给目录文件设置。
一般是谁设置，谁才能取消。（root除外）
只能给other设置。
