程序的地址空间
	认知-概念
————————————————————
高地址
		0xFFFFFFFF	
	内核空间
	命令参数(偏低)环境变量(偏高)
	栈区（地址向下增长）向下    -- 即地址数值越来越小
	共享 -- 映射
	堆区（地址向上增长）向上    -- 即地址数值越来越大
	未初始化全局数据区
	已初始化全局数据区
	代码区（静态区内置）
		0x00000000
低地址
 -- 4g大概
验证地址空间：
	(打印各种地址 --- 进程打印)
	[makefile：新增符号 -- $@ $^ (@表示变成对应的文件名(去掉后缀名)、^表示所依赖的后面全部文件)]
	代码段：%p main  常量-- 字面值(和正文一样 只读)
	全局变量：初始化全局数据、未初始化全局数据 static
	堆变量：malloc
	栈变量：函数内定义
	命令行参数：int argc  char* argv[] 
	环境变量：char* env[]
	[系统口诀：堆栈相对而生，从低到高代码 初始化数据 未初始化数据 堆 共享区 栈 命令行参数环境变量]
	[在堆申请的空间字节数，free是如何知道是多少字节的：c标准库一般会多出一部分空间申请，这多出来的就是保存申请的属性信息，所以这样free也能找到了]
	
	[vim 使用ctrl v进入批量处理模式 然后hjkl进行选择，然后shift i进行编辑//就可以进行连续注释了 取消就是 d]

	引入：父子进程在一段代码里公用一个全局变量，分别打印其地址均为一样。
	（两个进程是互相独立的 -- 提出问题：同一个地址，同时读取出现不同的值）
	得出结论：这里的地址不是物理内存的地址。--（相同地址在同一时刻读取值不同）
		--虚拟地址（线性地址）
	
	（是否和C语言中的指针概念冲突？解释：几乎所有的语言，如果有所谓的地址概念，此地址一定就是虚拟地址）

虚拟地址：
	存储（内存、外设内存的集合）的不同，为了统一化进行管理，就引入了虚拟内存的概念，一对一进行映射。（了解）
	
补充：(32位一下，一个进程的地址空间，取值为 0X0000 0000 ~ 0XFFFF FFFF)
	[3GB 4GB]  [0GB 3GB]
	内核空间 vs 用户空间

	Linux vs windows
	上述验证对Linux有效  windows可能不存在有效 	
————————————————————

	地址空间
	是什么
————————————————————
现实中的饼 vs 画饼
物理内存        地址空间(虚拟内存)

画的人就是操作系统
但是画的饼，也要进行管理 -- 所以也要进行先描述，在组织
所以内核中的地址空间，本质也是一种数据结构。和一个特定的进程关联起来。

历史计算机上，进程写入是直接加载物理内存的，内存本身是可以被随时读写的。如果其中一个进程存在野指针，那么就会影响其他地方的数据以及储存。 -- 特别不安全   不是独立性的
不能直接使用物理地址。

现代计算机：
task_struct  会创建一个数据结构：虚拟地址空间  认为其地址就是0x0000 0000 0xffff ffff
非物理内存存储。-- 虚拟地址   系统存在一种映射机制(虚拟地址映射到物理内存)  要访问物理内存，就要进行映射
保护机制可以类比于家人收压岁钱   -- 此时非法访问也就可以进行禁止映射 

如何理解区域划分？
struct destop{
	int start;
	int end;
}
struct destop one = {1, 50}
struct destop two = {51, 100}
所谓的区域划分，就是在一个范围内定义一个start和end


————————————————————

	所以地址空间是？
	怎么办
————————————————————
地址空间是一种内核数据结构，里面至少要有各个地址区域的划分：
比如：
struct addr_room
{
	int code_start;
	int code_end;

	int init_start;
	int init_end;
	
	...
}
所谓的范围变化 本质就是对start或者end标记值+-进行调整即可。

struct mm_struct{}  // 当前进程的地址空间  在pcb内Linux就是tesk_struct就存在此地址空间的指针。(这样每一个进程就会对应有一个地址空间)

映射关系是操作系统自己维护，是一个页表结构。
struct mm_struct                        映射关系(页表)                                   物理内存
地址空间和页表(用户及)每个进程私有一份。
只要保证每个进程的页表映射物理内存的不同区域，就能做到进程之间不会进行互相干扰，保证进程的独立性。
回答之前的现象：即虽然地址空间类似，但是页表的映射不同进程之间并不相同，所以物理内存里面所改变的值也就不一样了。
 -- 写时拷贝(在子进程需要修改与父进程类似的的变量的时候，就会重新映射到一个新的物理内存区域进行修改(即页表的指向))
此时也可以解释之前的fork()返回的两个值的问题。
父进程返回子进程pid，子进程返回0，否则-1
return的本质就是对id进行写入。
返回的时候就会发生写时拷贝，所以父子进程在各自的物理内存有属于自己的变量空间，用户层就是同一个虚拟地址。

扩展内容： -- (尽力而为)
	objdump -afh 程序名  反汇编工具  VMV
	程序还未加载到内存的时候，就已经存在地址了。
	可执行程序 编译的时候内部存在地址
	地址空间不仅仅理解为OS内部需要遵守的，其实编译器也要遵守。编译器在编译的时候已经形成了各种区域。并且采用和Linux内核一样的编址方式，给每一个变量，每一行代码进行了编制，所以程序在运行的时候，已经具有一个虚拟地址了。
	程序内部的地址依然使用的是编译器编译好的虚拟地址，加载入内存后，每行代码，每个变量都具有物理地址，然后PCB中加入地址空间就可以按照此进行编排，然后页表一段链接地址空间，另一端连接物理空间。CPU读到指令的时候，指令内部的地址就是虚拟地址。
    深入理解虚拟地址：
PCB  1 	                           				 页表  2
mm_struct 地址空间				虚拟地址          物理地址
此时将每个部分虚拟地址最大最小填充                                  相互映射
		   
 物理内存	   3		                 磁盘   4
程序加载进行虚拟地址不变		 test.c （每个变量和函数，都有地址，是编译器给你的，一样也被加载到物理内存）
但是每一个变量或者函数外部是物理地址     mytest（程序,内部存在地址，必须要标记函数位置以及调用接口）
							（比如相互调用）

所以CPU读到的指令内部，使用的也就是虚拟地址。  cpu从物理空间内读到的虚拟地址也就是原本从地址空间内读取的虚拟地址通过页表虚拟内存映射的物理内存地址找到的虚拟地址。
页表 左边就是原本编译程序的地址空间的每一行代码的地址，然后对应的进行复原地址空间 
右边就是对应创建的物理地址，用来保存每一行代码和数据。所以物理空间内保存的就是每一行代码的数据。此时这个地址就是虚拟地址。

设计了一种操作系统看向物理内存的一种方案
————————————————————

	为什么
————————————————————
为什么要有地址空间？？
1.凡是非法的访问，或者映射，OS都会识别，并且终止这个进程！-- 保护了物理内存
	物理内存可以直接读写修改
	但是比如在程序中对只读常量进行修改的时候，就会报错  这就是页表的操作 在软件层次上阻止了这次操作。。即非法访问。所有的进程崩溃，本质就是进程退出。操作系统干掉的。
		那么，操作系统如何识别？（多线程）
		如何干掉的呢？（信号）
	
	操作系统创建并维护了地址空间和页表，所以利用其进行映射，就要经过OS的监管下进行访问。
2.内存管理模块 vs 进程管理模块(调度调的就是这个) 解耦合（减少模块之间的关联性）分配内存采用延迟分配策略 提高整机的效率。
因为有地址空间的存在，页表映射的存在，所以在物理内存中，就可以对数据进行任意位置加载。
	物理内存的分配就可以和进程的管理，只要映射到就行。（地址空间和页表就是一个进程管理模块 物理内存和磁盘就是一个内存管理模块）
 		内存管理模块 vs 进程管理模块 解耦合（减少模块之间的关联性）
	用户层操作实际上用的内存管理均是虚拟内存
	所以C/C++语言上进行new malloc的时候，就是从虚拟地址空间申请的。
	如果申请了物理内存，不立马使用，就会造成空间的浪费。
		本质上，（因为有地址空间的存在，所以上层申请空间，其实是在地址空间上申请的，物理内存可以不给你一个字节。而当你真正进行对物理地址空间访问的时候，才执行内存的相关管理算法，帮你申请内存，构建页表映射关系），然后在让你进行内存的访问。
	（）完全是由操作系统，自动完成，用户，包括进程，完全零感知~（缺页操作） 	几乎内存的有效使用是百分之百的
3.因为物理内存理论上可以仍以位置加载，物理内存中几乎所有的数据和代码是不是乱序的？因为页表的存在，它可以将地址空间上的虚拟地址和物理地址进行映射，那么在进程视角的内存分布，都是可以有序的。
	那么地址空间加页表的存在可以将内存空间有序化。
	地址空间是OS给进程画的大饼  -> 进程要访问的物理内存中的数据和代码可能目前没有在当前物理内存中（2）同样的也可以让不同的进程映射到不同的物理内存，是不是很容易做到进程独立性的存在。-> 进程的独立性，可以通过地址空间+页表的方式实现。
	-> 因为由地址空间的存在，每个进程都认为自己有4gb(32)，每个区域都是有序的，进而可以通过页表映射到不同的区域。因此，来实现了进程的独立性。
	一个进程只知道自己的存在。


什么叫挂起：
（加载本质创建进程  那么是否必须非得立马将程序的代码和数据加载到内存，并且创建内核数据结构建立映射关系？）
在最极端的情况下，只有内核结构被创建出来了。 --- 新建状态 ->调度时就加载-> 理论上可以实现对程序的分批加载！
	可以分批加载，也就可以分批换出
	甚至，这个进程短时间不会再被执行了，比如阻塞。
	进程的数据和代码就被换出了，挂起
	所以页表的右侧不一定是对应的内存的地址，而是磁盘对应地址，而内存里相关数据就可以直接free掉了。
									磁盘
									代码 数据
									./ 运行  -- 内核PCB描述、代码数据
————————————————————