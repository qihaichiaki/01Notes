linux-windows-vscode联合开发
	vscode-编辑器
远程链接服务器：安装remote	f1 - remote - 添加公有ip
ctrl ~  -- 远程打开命令行



------------------进程间通信：
	进程运行具有独立性--进程想通信，难度比较大-- 进程间通信的本质：先让不同的进程看到同一份资源（内存空间）
		通信的目的-交换数据
	为什么要进行进程间通信：数据传输，资源共享，通知事件，进程控制 -- 多进程协同。
管道 - 匿名管道pipe 命名管道
	
System V IPC	（本地通信）
POSIX IPC	（网络通信纳入）--网络通信-既能本地，又能网络


--------------------
管道是Unix中最古老的进程间通信的形式。
管道：现实生活中的管道：天然气管道，石油管道，自来水管道  -- 只能单向通信。
	管道中传送的都是资源。计算机中的管道同样如此。-> 数据！（互联网公司最重要的资源是数据）感性

一个进程链接到另一个进程的数据流称为管道--一定是操作系统给的 - 资源一定是由操作系统提供，进程间必须独立
	如果当前进程创建了子进程 -- 创建一个新的PCB ，必须要给子进程拷贝一份struct files_struct。但是struct file不会被拷贝。
与进程相关拷贝、文件不会变。此时两个struct files_struct的指向文件相同。
	fork 此时继承文件描述表 -- 父子都可以看到的文件资源 实际上就是管道。 


----------------------------------------
进程间通信的必要性
以前的程序：单进程的、无法使用并发能力，无法实现多进程协同处理。
	进程的作用：传输数据、同步执行流、消息通知。
	-进程间通信是手段，目的为了多进程协同

-----------------------------------------
进程间通信的技术背景
1.进程具有独立性。虚拟地址空间、页表（进程内核数据结构+代码和数据）
2.通信的成本比较高。

-------------------------------------------
进程间通信的本质理解：
	1.前提：不同的进程看到同一块“内存”（特定的结构组织的）
	2.所谓的进程看到同一块“内存”属于哪个进程呢？-不能隶属于任何一个进程，强调共享的特性。

--------------------------------------------
进程间通信的方式	标准
1.Linux系统原身提供 - 管道 - （匿名、命名）
2.SystemV IPC	（多进程 ） - 单机通信
	共享内存
	消息队列（不常用）
	信号量（原理）
3.POSIX IPC --  （多线程中讲）- 网络通信
	标准更多是在使用者上存在一定的规律

---------------------------------------------
管道 - 有入口、有出口 -简化：有一个入口，一个出口
	特点：管道都是单向传输内容的、管道传输的都是“资源”
	计算机通信领域的设计者设计了一种单向通信的方式 -- 管道

-----------
管道的原理：
	管道通信背后是进程之间通过管道进行通信。
		进程相关数据结构				被打开的文件相关内核结构
	task_struct
			files_struct->fd_array[]		struct file		inode属性
			0				标准输入	         内核缓冲区-（address_space）
			1				标准输出
			2				标准错误
			....
1.分别以读写方式打开同一个文件
2.fork()创建子进程 子进程创建PCB、文件描述表。但是表结构此时指向的文件和父进程指向一样（包括刚刚读写打开的文件3r4w）
	-- 此时就是不同的进程看到了同一份资源（内存）
3.双方进程各自关闭不需要的文件描述符。-规定方向。
	ed 父进程进行写入，子进程进行读取（父进程关闭读端 - 4写入，子进程关闭读端 - 3读出）
	--文件描述符的方式创建了管道

管道就是文件-基本的通信方式
	此时进程通信，没有必要刷新到磁盘 - 保证纯内存级操作

所有的进程间通信不会出现写入磁盘中去。

------------
编码：
1.demo代码 如何做到让不同的进程，看到同一份资源呢?管道 - 常用于父子进程
	1创建管道
	pipe - 系统调用接口 unistd.h
	int pipe(int pipefd[2]) (输出型参数、成功 0 失败 -1 设置错误码 - 读写打开内存文件)
	（注意在relis版本下，没有使用的话，会告警 - (void)n表示使用了）
	ctrl+· 打开终端 
		pipefd[0] fd	 r文件描述符
		pipefd[1] fd	 w文件描述符
	-DDEBUG - 设置条件编译宏 在g++后 #ifdef DEBUG #endif 这段代码条件编译
	2fork 创建子进程
	3构建单向通信 - pp-w p-r
		关闭子进程不需要的fd(这里保留读，关闭写)	close(pipfd[1]);
		关闭父进程的读 close(pipfd[0]);
		  
	4进行通信：
		子进程 read(fd, buufer, sizeof(buffer) - 1);	ssize_t s(有符号的长整形) 返回 >0 读取成功 读取了多少个数据 最后一个字符添加0 \0
		父进程  -（C++、C混合使用）C++ - string
			char[1024]
			构建变化的字符串
				snprintf(char*, sizeof(), "%s : % d", string.c_str(), 计数器) - 安全的格式化写入缓冲区（snprintf通过提供缓冲区的可用大小传入参数来保证缓冲区的不溢出，如果超出缓冲区大小则进行截断）snprintf函数返回的是应该输出到字符串缓冲的字符个数 - sprintf函数返回的是实际输出到字符串缓冲中的字符个数，包括null结束符。
			写入
				write(pipfd[1]，char*, strlen(char*) ) - 系统调用接口 写入失败返回-1
		
		父进程进行等待waitpid();
		进程退出-文件描述符一定会被关掉
	注意不可定义全局buffer-父子具有写时拷贝 。
	
	
2.总结管道的特点 - 理解以前的管道
	1.管道是用来进行具有血缘关系的进程进行进程间通信 -- 父子进程（子进程继承父进程的管道信息）
	管道是一个文件、显示器也是一个文件，父子进程同时往显示器写入的时候，不会出现一个等另一个进程的概念。-缺乏访问控制。而管道就具有访问控制。2.管道具有通过让进程间协同，提供了访问控制！
		如果读和写速度不同，一段让其写满或者读完时，一段就会等待另外一方将管道里数据读取或者写入才可继续进行操作。
	3.管道提供的是面向流式的服务 - 面向字节流 - 协议进行数据区分（网络去讲）
	4.管道是基于文件的。// 对于读出的那一段：写入的那一方，fd没有关闭，如果有数据就读，没有就等
			// 			fd关闭	读完了就读到文件结尾，返回0 
	文件的生命周期是随进程的，管道也是。-通信双方退出，管道自动退出。
	5.管道是单向通信的。半双工通信的一种特殊情况。	（要么在收、要么输）	全双工（都即在收、输）
			a、写快，读满，写满不能在写了。
			b、写慢、读快 ，管道没有数据，读必须等待
			c、 写关、读0，标识到文件末尾。
			d、读关、写继续写，OS终止写进程


3.扩展
	uint32_t command = 0;  // 四个字节
	单机版的负载均衡 - 一个父进程，均衡的将任务派发给子进程
	---进程池	本地任务请求-随机数方式的负载均衡
		进程协同
		// 代码中关于fd的处理，有一个小问题，但不影响使用，你能找到吗？


原子：做/不做 无中间状态
不小于 4096byte - 管道传输的数据 - Linux下


----------------------------
命名管道
毫不相关的进程如何进行通信呢？
	-先要让不同的进程看到同一份资源。
	不同进程打开同一个文件 - 此时内核之间就可以看到同一份资源了。
		磁盘上创建一个管道文件 - 可以被打开，但是数据不会被刷新到磁盘。-不会io操作
		-命名管道文件
		有名字，改文件一定在系统路径中。路径具有唯一性。双方进程就可以通过管道文件的路径看到同一份资源。
-------
小实验：
	mkfifo - 当前路径下创建命名管道文件（也可以指定文件） p开头
	echo "hello world" > 管道文件 -（对方没有读，就会阻塞）另一个cat < 管道文件 读取即可
	unlink 删除管道文件。
------
编写简单代码
	 man 3 mkfifo      int ("路径", mode_t mode);	0成功 -1错误  mode 为文件权限 - 八进程 0666
生成两个可执行程序 - 不同的进程进行通信
	.h看到一个
		#ifndef _COMM_H_  #define _COMM_H_ (如果没有定义)
	一个文件创建管道文件
	.hpp .h
	.cxx - .cpp .cc
	mkfifo(const char* , 0666);
	
	memset <cstdio> <cstring>  - 包c语言头文件的C++做法
	cerr - 标准错误
	unlink 系统接口 - unlink(const char*) -- 删掉管道文件

	同样的，只是读打开此管道文件，没有写打开的话会阻塞。
	Log.hpp - 日志文件



-----------------------------------------
SystemV IPC 共享内存的通信方案
1.原理：
	操作系统即开辟一段内存，通过页表映射-到进程地址空间里的共享区，就可以让不同进程之间共享内存。释放-先去掉映射，然后释放掉即可。
-------------------
共享内存的建立
	共享内存的提供者是操作系统，并且也要进行管理共享内存。-管理方式：先描述在组织。
	共享内存 = 共享内存块 + 共享内存的内核数据结构
---------------
创建代码
	man 2 shmget - 专门进程通信的 - 系统接口
	int shmget(key_t key, size_t size, int shmflg);
		shmflg :IPC_CREAT 单独如果创建共享，底层存在，会获取并且返回，不存在创建就返回     0（不是创建的话建议设置为0）
		            IPC_EXCL：单独使用没有价值
			合起来使用：如果底层不存在创建并且返回。底层存在出错并且返回。
			同样的包含权限。0666 perms
		成功返回合法的标识符 - 共享内存的用户层标识符，类似曾经的fd shmid
		失败就返回-1，设置错误码
		size ：大小 - 共享内存的大小最好是页的整数倍。（PAGE：4096）4kb  如果不是，那么就会多创建空间，并且浪费掉。即操作系统会创建包含此大小的页数。

		key：要通信的对方进程，怎么保证对方能看到，并且看到的就是我自己看的共享内存呢？
			通过key就可以了，数据是多少不重要，只要能在系统中保持唯一即可。此时两进程是由同一个key，此时就是同一个共享内存。
			key就是使用同一算法形成的唯一值。
	man 3 ftok 算法 - 唯一值
	key_t ftok(const char *pathname, int proj_id);proj_id项目id - 随便设置 0 ~255 - 不一定会百分百创建成功。
	小于零失败


comm.hpp


	#define PATH_NAME "/home/..."  - 保证该路径有权限
	ID随便写
	key_t -- int类型
	
	1.创建公共的key值
	2.创建共享内存 - 建议创建一个全新的共享内存-通信的发起者。
	

进程运行结束共享内存还是存在的	ipcs -m 查看ipc资源 m就是共享内存（q消息队列 s信号量）
				ipcrm -m shmid对应的共享内存 - 删除（共享内存只有在当前映射连接数为0时才会被删除释放	使用ipcrm -a选项可以删除所有进程间通信资源）

	system V IPC资源，生命周期随内核的！-随着操作系统一直存在，除非重启。手动删除：ipcrm -m shmid
			代码删除:	man shmctl    int shmctl(int shmid, int cmd, struct shmid_ds *buf);
				cmd 不同的操作：IPC_RMID - 删除即使有其他进程挂接，还是删除。
				buf：nullptr
			成功0 失败返回-1
	
		attach - 映射、关联
		dettach - 删除关联
		nattach -关联个数
	3.指定的共享内存，挂接自己的地址空间
	挂接：void* shmat(int shmid, const void* shmaddr, int shmfg);
		shmaddr:挂接形式... nullptr 
		shmfg:操作
		返回nullptr挂接失败
	char* shmaddr = (void)shmat(shmid, nullptr, 0);
	4.指定的内存共享去关联
		int n = shmdt(shmaddr);
	-1同样小于零失败 

	操作共享内存都是shmid


	共享内存、内存映射、共享库 - 这些也都是用户层的。（共享内存）用户层也就是不用通过系统调用，直接进行访问。
		双方进程如果要通信，直接内存级的读和写即可。
	那么为什么pipe、fifo、都要通过read、write来进行通信呀。-系统调用接口。为什么？公共资源 - 是属于文件，是属于内核资源，操作系统需要对其管理。


-----------共享内存通信- char* shamddr  -共享内存起始地址空间。
--想象为malloc出的一块大空间。当做字符串来用
	服务端读取：while(1){%s, }  创建出来会默认全零。

	客户端写入：-一样看做一个char类型的buffer即可。
		可以使用sprintf（snprintf-安全版本）每次向shmaddr  - 起始地址-共享内存

	\- C/C++ 续行符。

	结论1：只要是通信双方使用共享内存，一方直接向共享内存中写入数据，另一方就可以立马看到对方的数据。共享内存是所有进程间通信（IPC），速度最快的！---不需要过多的拷贝。（不需要将数据交给操作系统）
	
在管道中，从外设到缓冲区-一次拷贝。（另外在语言层也有一层缓冲区-可以不考虑）发送到管道文件也是一次拷贝。管道文件在到拷贝自己定义的的用户是一次拷贝，在printf-也是一层拷贝。
同样的操作，采用共享内存：可以直接从外设直接到共享内存里，读的时候是直接从内存里读取即可。--最多的话（键盘读入一次，打印到屏幕上一次）
	结论2：管道是提供了访问控制的。共享内存并没有访问控制。会带来并发问题。（写了一半，但是没写完就都读了。--此时意思完全改变了 -- ）（如果想进行一定的访问控制呢？-当然能）
	利用管道来实现共享内存。---客户端写数据，让对方读对方就读。
		利用管道的同步和互斥。

system V消息队列 - 选学（过时）
	msgget -- man 2 
	msgctl -- man2
	msgsnd
	msgrcv

system V信号量 - 选学（）
	（多线程的时候讲---）


与文件操作不兼容。-所以过时了。不好与后序的网络服务进行兼容。
------------------------------------------------------------
信号量 - 概念铺垫：也是属于进程通信
	基于共享内存的理解：
	为了让进程间通信 --> 让不同的进程之间，看到同一份资源 -> 之前的所有通信方式-本质都是优先解决一个问题：让不同的进程看到同一份资源。
		--> 让不同的进程看到同一份资源，比如共享内存，但是也带来了一些时序问题。（比如之前没有进行访问控制）此时就会造成数据不一致问题。
		四个概念：
			1.把多个进程（执行流）看到的公共的一份资源 -- 临界资源。（一般这种公共资源需要保护，这样的话在任意时刻只有一份执行流访问此临界资源（前提是多执行流去访问））
			2.我们把自己的进程，访问临界资源的代码 -- 临界区（很少量的代码）
	（所以两个或者多个执行流，互相运行的时候互相干扰，主要是我们不加保护的访问了同样的资源，在非临界区多个执行流互相是不影响的）
			3.为了更好的进行临界区的保护，可以让多执行流在任何时刻，都只能有一个进程进入临界区  -- 互斥！
			4.原子性（下面引入）：要么做，要么做完，没有中间状态，就称之为原子态。



-----------------------------------
	电影院 - 宏观上的临界资源  		人想要进来看电影 - 执行临界区代码
	看电影一定要有座位（里面的一个资源），这个座位真正属于你，并不是你坐在上面就是你的了。-先买票，只要我买了票，我就拥有了这个位置。买票的本质 ： 对座位的 |预定| 机制。
	可以允许多个执行流访问临界资源内不同的区域。当然，同时限制流个数自然就是此资源里面的区域个数，并且也保证里面访问每块区域的进程并不重复。
		-每一个进程想进入临界资源，访问临界资源的一部分，不能让进程直接去使用临界资源，你需要先去申请信号量（先买票）
	
------------

定义信号量
	本质是一个计数器，类似 int count = n; （不准确）- 先申请信号量：1.申请信号量的本质：让信号量计数器--。2.只要申请信号量成功，临界资源内部一定给你预留了你想要的资源 -- 申请信号量的本质实际就是对临界资源的一种预留机制。 - 申请信号量（--） -> 访问临界资源 -> 释放信号量（++） 
		（进程执行自己的临界区代码）
	********
	计数器 -- 信号量的P操作 -> 必须是原子的。
	计数器++ 信号量的V操作 -> 必须是原子的。
	信号量是对临界资源的预定。
	********

-----------------------
	信号量是一个计数器，int n = 10；用一个整数能否表示信号量呢？
		（不能，不同之前的进程 - 写实拷贝（父子进程） 不可见（进程之前具有独立性））
	现在假设（在共享内存里）能够看到一个全局变量。大家都申请信号量 n ---- 也是不可以的。
		client：n--写入共享内存n++
		server：n--读取共享内存n++;
	cpu	进程			内存：				
（计算在CPU）	client			n = 5（数据在n变量里）
		server	

	cpu执行指令的时候三个步骤：1.将内存中的数据加载入cpu的寄存器（读指令）
				2.n--（++）分析与执行指令
				3. 将cpu修改完毕的n写回内存（写回内存）
		client：n-- -> n=5 加载入edx 
		server: n-- -> n=5*** 加载入edx
			寄存器只有一套，被所有的执行流共享，寄存器里面的数据属于每一个执行流，属于该执行流的上下文数据。进程切换，上下文保护，恢复。
			（进程在任何时候都可能被切换，也就是说在写回内存之前，就可能发生了进程切换，保留上下文，那么此时相当于n的数据被两个进程独立起来了，执行结果就变了）
			n--：因为时序问题而导致的n有中间状态，可能导致数据不一致。此处的n就是不安全的。如果一个n--操作只有一行汇编。该操作是原子的。！！！



		