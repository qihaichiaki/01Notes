udp   1
tcp    2

预备知识：
	源IP和目的IP。mac地址一直都在变化（同一个局域网里进行跳）
	IP地址（下面使用公网IP），公网IP和私有IP在特定的区域保证唯一性-->（IPV4）这样也就标定了主机的唯一性。
	IPA 软件客户端					IPB 服务器软件
	<--------------------------------------------------------------->
		通常情况下：把数据送到对方的机器是目的吗？
		不是机器在通信，而是机器上的软件在通信。
		客户端进程 ---------------    服务器进程
		主机	         < ->	主机
		真正的网络通信过程本质就是进程间通信！将数据在主机间转发仅仅是手段。机器收到后，交付给指定的进程！

		应用层	网络进程 - 和对应的端口号相连 进程持有一个端口号
		操作系统	TCP	解包识别端口号，传到对应进程
			IP	IPX
			MAC

	端口号：传输层协议的内容。是标识特定主机上的网络进程的唯一性！
		IP+端口 -> 主机的唯一性+进程的唯一性  ---全网的唯一进程---
		任何一个发出的报文：ip，port
		端口号和进程pid：分开区分。解耦。
			一个进程可以和多个端口号绑定。但是一个端口号不可被多个进程绑定。
			端口号->进程 必须是一对一的。
		源端口号和目的端口号：谁发的，谁接收
	
		{SRC_IP,SRC_PORT}    {DST_IP,DST_POST}-----> 套接字
		源ip、端口号             目标ip 、目标端口号
		
		套接字编程。
	
	认识TCP协议和udp协议 -传输层-
		UDP：用户数据报协议     --发邮件
			无连接
			不可靠传输（丢包等问题）
			面向数据报
		TCP：传输控制协议	  --打电话
			有连接
			可靠传输
			面向字节流

		可靠指的是中性描述。出现丢包问题，在有些场景下容忍不可靠的。可靠性是需要大量的编码和处理的。UDP只是把数据发出了，更加简单。---选择协议的时候，根据场景需求：比如直播、视频网站适合使用UDP协议去做。	
	网络字节序：
		数据 -> 网络 -> 数据
		（大小端-存储数据的方案）
		如果两个主机的存储数据的方案不一样，那么该如何处理数据呢？
		网络规定，所有网络数据，必须是大端字节序。
		-网络为何采用大端？-
		
		C语言提供的
		htonl(uint32_t )  主机序列转化为网络
		ntohl(uint32_t )  网络转化为主机
		homes  


	常见的套接字：		
		1.域间socket  命名管道-类似
		2.原始socket  编写很多工具 - 饶过很多上层协议使用底层。
		3.网络socket  
	理论上是三种应用场景，对应的是三套接口。->Linux不想设计过多的接口->将所有的接口统一。
	
	sockaddr结构：
	网络套接字：标志类型 16位端口 32IP地址	_in	AF_INET   // PF_INET
	域间套接字：标志类型 108byte路径名     	_un	AF_UNIX
	通用：前两个字节：标志类型 		sockaddr
	....
	

udp网络编程：
	udp_client.cc  客户端
		// 首先创建套接字
		// 客户端要不要绑定本地进程 -要，但是客户端一般不会显示的bind - 即程序员一般不会自己去bind。因为客户端是普通人下载安装启动的，如果程序员自己bind了，客户端bind了一个固定的端口。--万一其他的客户端占用了此port呢？所以客户端不需要显示的bind指定port - 让操作系统自己随机的进行选择（什么时候做的呢）。
		// 发消息 需要知道服务器的ip和port - 可以利用命令行参数
		sendto(套接字对象, const void*buf, len, flags, 发给服务器的ip和端口, len(获取结构体的大小)) 	首先在外面定义套接字结构体  sockaddr_in  memset 进行清空
		用命令行参数进行填充选项
		当客户端首次发送消息给服务器的时候，OS会自动给客户端的ip和端口
		
		// 客户端读取数据   -- udp 一般保留的有
		ssize_t recvfrom(套接字, buf, buf-len(缓冲区-大小 可以预留一个空间), int flags(读取的方式，默认为0时是阻塞读取), sockaddr* src_addr, socklen_t *addrlen（其他信息）)
		

	
	udp_server.cc  服务器端
		// 一个服务器一般必须需要ip地址和port(端口号-16位的整数)
		string ip uint16_t port int sock -套接字对象
		(00.00.00.00  -- )

		// 使用智能指针进行管控
		// 运行服务器：./udp_server ip port  -> 存在云服务器的一个小bug
		usage(string) -> 使用手册  编写
		
		// 初始化服务器：-> bool
			// 网络编程 - > 1创建套接字：int socket(int domain, int type, int protocol)
				成功的时候返回一个类似文件描述符。-1失败
				domain: 套接字的域  创建哪一种套接字(网络、域间、原始....) AF_INET -ipv4的网络 AF_INET6 -ipv6    ----网络还是本地
				type：类型，通信种类。（文件、管道叫做流式 udp是数据报 - SOCK_DGRAM）  ---- 什么方式：流还是数据报
				protocol:基本前面两个确定，此协议也就确定了。-一般写为0即可。
			// cerrno strerror-> 把错误码转化为错误码描述  错误检查
			
			// 2.bind:将用户设置的ip和port在内核中和当前的进程进行强关联。
			sockaddr_in  字段属性填充
				bzero (void* size_t) 目标地址 清0 - 初始化
				sin_family = AF_INET;  // 表示协议家族
				sin_port = htons(_port);  // 服务器的ip和端口未来也是要发送给对方主机的。-> 先要将数据发送到网络  短整数2字节 s 转化为网络
				// 同上，首先要将点分式ip转化为4字节，4字节主机序列->网络序列
				// 存在一套接口，可以做完这两件事情。
				sin_addr.s_addr = inet_addr(char*)-> 返回32位整数

			int bind(int sockfd, const sockaddr*, 大小)
				成功0，-1错误
				sockfd：套接字
				sockaddr:通用的结构体 - sockaddr_in 网络使用（netinet/in.h  arpa/inet.h  需要此头文件包含） 注意需要强转为通用的结构体类型

			192.163.1.3 ->点分十进制字符串风格的ip地址：每一个区域在数字上取值范围是[0-255] 1字节 -> 4个区域  实际上ip地址，4字节就可以了 点分十进制需要转化为4字节。

			// done				

		// 启动服务器
			// echo server 发送消息，然后原封不动返回
			// 做为一款网络服务器，永远是不会退出的！
			// 操作系统：服务器启动-> 进程 -> 常驻进程 -> 永远在内存中存在，除非挂掉了 绝对死循环  
			// 1.读取数据
				ssize_t recvfrom(套接字, buf, buf-len(缓冲区-大小 可以预留一个空间), int flags(读取的方式，默认为0时是阻塞读取), sockaddr* src_addr, socklen_t *addrlen（其他信息）)
				除了拿到数据，我们也需要时谁发送的消息 --src_ip src_port(客户端的ip和端口port) src_addr addrlen 这两个参数都是输出型参数。
				读取失败-1返回 ssize 有符号
				socklen_t -- uint32_t  // 需要注意src_addr纯输出型，socklen_t 输入输出型参数：输入：src_addr缓冲区大小，输出读到的结构体大小
			目前将数据当做字符串
			 	// 1输出发送的数据信息
				// 2 是谁？-
					//别忘了从网络来的需要转化为主机序列：ntohs s是2字节 
					// 从网络里来的ip 转为主机 char* inet_ntoa(addr);						
				
			// 2.分析和处理数据 Too
			// 3.写回数据
				sendto(套接字对象, const void*buf, len, flags, 发给对方的ip和端口-> 收到客户端的结构体对象, len(获取结构体的大小))
			
			对套接字对象-文件描述符关闭 close
			

			FILE* popen(char* command, const char* type)
			//1 执行command->pipe() fork() 子进程执行(exec*) command 命令
			//2 FLIE* :可以将执行结果通过此type进行执行 r w...
			
			


	netstat - 查看本地主机的服务器启动情况
		-a(all)n(显示数字)u(udp)p(进程)


	

		

127.0.0.1 本地环回：
	客户端和服务器端发送数据只会在本地协议栈进行数据流动，不会把我们的数据发送的网络组
	只是在本地协议栈走一走，本地网络服务器的测试 - 127走通了，如果网络走不通了，那么网络就存在问题。--类似于本地间的进程通信。

云服务器：
	1.云服务器无法绑定公网IP - 不建议。服务器来讲，也不推荐绑定确定的IP - 所以一般绑定INADDR_ANY -> 宏 就是 0 让服务器在工作过程中可以从任意IP中获取数据。  -- 这样任意链接此服务器的ip都可以对其进行访问。
				
	120.78.126.148
	代码实操：多人在线聊天服务器+客户端 -- 客户端利用多线程一读一写 服务器端可以将消息发送给目标ip   服务器端 - 多线程，一个线程存数据，另一个进行广播到其他即可。

	发现问题：无论读还是写，使用的都是同一个sock，sock代表的就是文件，UDP是全双工的->传输层的特点：可以同时进行收和发而不受影响。半双工：收的时候只能听 说的时候不可听
	创建命名管道 mkfifo		
	
	注意，windows下的套接字编程和Linux基本一模一样
	windows独有用法：
		WinSock2.h  #pragma comment(lib, "ws2_32.lib")  // 固定用法
		WSADATA WSAData;  // win 初始化
		if (WSAStartup(MAKEWORD(2, 2), &wsd) != 0) {//初始化WSA
		WSACleanup();
		return -1;

		closesocket   WSACL
		WSACleanup();
	#pragma warning(disable:4996)   屏蔽对应错误



--***TCP网络编程***--
Server.hpp

class TcpServer
{
public:
	initServer()
	{
	创建套接字：
		SOCK_STREAM - TCP套接字-基于流式的
		soke = soket(AF_INET(网络通信), SOCK_STREAM(流式套接), 0);
			查错处理-致命错误 套接字创建失败
		// 此时可以查一下此时返回的soke的值 -> 流传输和文件操作类似
	绑定本机端口 ip:bind
		sockaddr_in local;  // 本主机的套接字结构体
		memset// 首先初始化 - 清0
		初始化属性：
			家族：AF_INET;
			port：注意需要主机转网络 -- 之后要和网络进行传输
			ip：绑定任意ip（解析上述有） 0-（INADDR_ANY）或者需要将其点分式转化为32位并且转网络操作：inet_addr(char* )
		if(bind() < 0)  // 这里注意需要转化类型
			查错处理。
	// TCP与UDP区别开始：UDP初始化绑定完后就初始化完了，但是TCP没有完成
	// 因为TCP是面向连接的，当我们正式通信的时候，需要先建立连接。
	建立连接：
		listen(int sockfd, int backlog);  // 成功0返回，-1错误
			const static int gbacklog = 20;  // 一般不能设置太大和太小 -后面再说
			差错处理
		// 处于监听状态，等待建立连接 请求
	}

	start()
	{
	// 首先是常驻进程
	while(true)
	{
	获取连接：
		连接我返回，没人连接阻塞
		int accept(int sockfd, sockaddr* addr// 输出参数, socklen_t* addrlen// 输入输出参数 - 对象大小);
			成功，返回一个接受了的sock套接字，否则-1，错误码被设置
			此时返回的sockfd - 专门针对服务的  servicesock
			外面的sock的获取新连接  -- listensock -监听套接字
			差错处理：继续下一次的获取，失败没有关系。
	// 获取连接成功
	获取对应ip和端口号
	通信服务：
		// 单进程循环版本1：
			服务接口：传入服务套接字+port+ip
				while(true)
				// read和write可以直接被使用
				s = read(服务套接字, 缓冲区);
				s > 0  正常读取
				s == 0  对端关闭连接
				s < 0 读取失败，<0 返回错误码
				
				// 然后写回去  --- 之后更改业务就在此处改  
				write()
			注意在当前版本下，一次只能处理一个客户端，处理完一个才可以处理下一个，显然不可使用。-为什么？用的是单进程 如何解决呢？
		// 多进程版本2.0：创建子进程，让子进程个新的连接提供服务。-子进程同样的能打开父进程所打开的文件。
			pid_t pid = fork();
			// 必须创建成功
			pid == 0
			// 子进程
				需要注意子进程退出必须要处理，--但是父进程不可等，父进程在处理自己的事情。非阻塞等待不好用。  以及信号捕捉都不好用  signal(SIGCHLD, SIG_IGN);  // 主动忽略sigchld的信号，会自动释放自己的僵尸状态。
				子进程是需要提供服务的，不需要知道监听套接字-close 只需要服务服务套接字即可，另外父进程也是关闭服务套接字即可（父进程必须要关，因为此文件描述符会越来越少... 直到最后服务器会崩溃的 - ）。
				服务接口。
			
		// 多进程版本2.1
		-子进程立即退出，子进程的子进程变成孤儿进程
			不能使用忽略信号。
			pid_t pid = fork();
			if (id == 0)
			{
				// child
				close lis
				if (fork() > 0) exit(0);
				服务接口。
				exit(0);
			}
			waitpid();	
			close ser		
		
		// 多线程版本
		ptread_t tid;
		pthread_create(&tid, nullptr, threadRoutine, 类);
		设置一个类，将上述服务接口里的参数加入，加入线程所在的回调函数 - 
		但是多线程版本存在线程安全问题--
		// 在多线程这里不需要关闭特定的文件描述符表 -- 因为此时适合服务器是共享的文件。
		// 多线程注意也存在内存泄漏问题，我们自己让线程自我分离即可
		
		// 利用线程池进行处理
		using func_t = ...  ->类似于typedef
		封装一下任务，每次对客户端服务的时候让线程池进行派发任务即可。
		别忘记了关闭服务套接字 -- 
			//hpp -头文件的一种
			// .h .c如果编译可能存在问题 	目录/%.依赖文件(存在问题)
		加上线程池，- 同时在线人数  所以一般服务器进行业务处理，如果是从连上到断开，要一直保持这个链接-常链接。后序对回调函数存在其他方案 -- while true
		服务器必须要有上限，服务器不可被挂掉，线程池--
	}
	}
private:
	uint16_t port;端口
	string ip;ip地址
}

Server:

main
{
	命令行参数判断。./tcp_server port
		错误，帮助菜单设计
	提取端口号
	创建对象-使用智能指针
	initServer();
	start();
}
	

client：客户端
./ ip port
	创建套接字
	// 我们不需要bind，但是一定需要port -即让操作系统自己去选择。
	// 客户端最需要的是连接别人的能力
	int connect(套接字, addr, addrlen);  // 连谁就可以了
		连接成功0返回，错误-1
		套接字代表的文件描述符就自动与服务器链接 - 自动绑定ip和端口
	首先在外面定义套接字结构体  sockaddr_in  memset 进行清空
	send - > TCP 网络发送接口 0设置为默认参数
	recv -> TCP 网络读取接口 0设置为默认参数
	
	s > 0  正常读取
	s == 0  对端关闭连接
	s < 0 读取失败，<0 返回错误码


netstat -antp  -- 查看tcp协议的服务 +l 只查看监听状态  U是udp

telnet 目标ip 目标端口号
--远程连接工具 ctrl ] + enter 运行 -- 可以充当客户端 ctrl+] quit 退出


注意服务器端和客户端，如果服务器端先关闭


1.TCP是面向连接的通信协议，在通信之前，需要进行三次握手，进行连接的建立 connect - 操作系统自己完成- accept(注意函数并不参与三次握手)

2.tcp在断开链接的时候，会进行四次挥手






	