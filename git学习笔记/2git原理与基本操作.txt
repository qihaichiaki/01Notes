问题引入：
	1设计一个项目的相关文档。（对一个文档进行多次修改）
		第一次修改
		第二次修改
		...
		第五次修改
	-如果此时需要第一次修改的数据就拿不到了。

	2再次设计一个项目的文档。（对一个文档进行多个版本的管理）
		文档v1
		文档v2 （对文档v1的副本进行修改）
		...
		文档v5
	问题：随着版本的不断增多，维护好版本存在挑战。（比如每个版本具体修改的是什么内容）
	
	3解决方案：版本控制器
		记录每次修改以及版本迭代的一个管理系统。

Git 是当下最主流的版本控制器，可以控制电脑上所有格式的文件。
对于开发人员，可以管理项目中的源代码文档。

	举例：文本格式文件，记录每次修改的什么，比如行数，新增了什么。（跟踪文件变化）
	二进制文件（图片、视频），具体改的内容不知，但是属性可知。（比如大小变化）



Git的安装
	查看Git是否安装：git --version
	
	Linux下的安装（centos）：
		删除：sudo yum remove git -y
		安装：sudo yum install git -y


Git的基本操作
	想要版本管理文件，需要放在git仓库中。

------------------初始化Git本地仓库
	命令 git init
		在当前目录会创教一个初始化Git本地仓库
		新增 .git/存在很多文件，它是用来追踪管理Git仓库的，记住不可修改里面的内容

------------------配置本地仓库
	配置两个配置项：（不配置会报错）
		name email
	命令 git config user.name "名字"
	命令 git config user.email "email地址"
	命令 git config -l 查看当前本地仓库的配置项目
	
	命令 git config --unset user.name ... 删除对应的config属性。

	--global
	命令 git config --global user.name "名字"
	命令 git config --global user.email "email地址"
	一台主机上可以创建多个本地仓库，加上--global表示在当前主机上生效在所有git仓库中。
	注意，使用--global选项，正常的--unset不可进行重置，还是需要在前面加上--global才可进行重置。
	命令 git config --global --unset user.name ...

------------------认识工作区、版本库、版本库中提交管理流程
放入当前文件夹不意味着此文件可以被git管理。实际上.git才是本地仓库（版本库）。但是不可将文件直接放在.git目录下。
	在.git目录所在的目录（一开始我们在对应文件夹git init的目录）是工作区（写文件的目录）。
当前虽然不行，但是存在一些手段是可以的。
	
	工作区				版本库.git
		-1add->				    HEAD指针指向master
	将工作区修改的内容			stage(暂存区/索引)	master
	（新增、修改、删除）		/index	  
						目录树				                
					   （存放对象库中git的索引）
						->2commit
						将暂存区的内容提交到master分支下。
						此时git就可以管理工作区中的文件。

					object 对象库（git对象：会将add修改的内容写入新的git对象）
					git对象维护到对象库中
					->维护了文件的所有版本哦

	版本库中的具体位置：
	stage：index（add后估计才会出现）
	master：HEAD指针指向
	object对象库：objects


------------------将工作区文件提交到版本库管理
命令：将工作区的修改添加进暂存区
	git add .(一般是将全部文件添加进)
	git add 指定文件1 指定文件2 ...

命令：将暂存区提交到master，这样对应工作区文件成功被Git管理了起来
	git commit -m ""
		必须加 后面是细节内容

命令：打印出从近到远的提交日志
	git log

		commit hashid（定义到每次的提交）...
	git log --pretty=oneline 打印一行漂亮可观的日志。

查看对.git版本库的影响
	add后会创建index 即保存暂存区中git对象的索引（一个git对象就是一次修改的内容）
	HEAD文件中保存commit提交到master的路径：ref: refs/heads/master（对应版本库文件下存在）
	而到对应master去看会发现，里面存放的是最新一次提交的hash-id。

	id与object对象库之间的关系
		对于一个id：10aa632ff44a84d0a671b7944c339f68ad4cac66
		10为对应文件夹的名字，后面aa632ff44a84d0a671b7944c339f68ad4cac66就是对应文件夹下的对象。
	查看git对象的内容：
		命令：git cat-file -p id
		能查看到谁提交的，日志、上一次提交的id、tree对象id（里面保存就是对应提交在master下的文件对应id）
		此时就能够发现，每一次commit提交工作区的数据都被.git变成git对象的形式保存了下来。
	
总结：
	index：暂存区，放add新增的内容。
	head：指针，指向ref: refs/heads/master
	master：存放的是最新一次的commit id。->git对象，git对象维护到对象库中，查看git维护的文件。
	
	需要注意：commit只是将暂存区内的内容写入到本地仓库中的。	


Git追踪管理的其实是修改，而不是文件。
Object内存放的git就是修改的内容。	
------------------修改文件
	修改文件。
	命令：git status 查看当前本地仓库状态
		就是将上次提交的状态和当前的状态进行对比：
		查看暂存区、工作区与object之间的差异
		注意：只能查看哪个文件修改了，但是不知道修改的细节。
	命令：git diff 文件 显示暂存区和工作区之间的差异
		比如：ReadMe
		diff --git a/ReadMe b/ReadMe （a：改动前、b改动后
		---改动前
		+++改动后
		@@ -1(-：改动前 1：第一行内容) +1,2(+:改动后 第一行开始，连续2行的内容)@@
		修改的内容
	命令：git diff HEAD -- [file] 查看版本库和工作区文件的区别
		类似	

------------------git的重要能力之一：版本回退功能
	Git能够管理文件的历史版本，这也是版本控制器的重要能力。
	想要版本回退，那么就需要执行git的版本回退指令。
	
	命令：git reset [--soft | --mixed | --hard] [HEAD] id	回退版本
		本质是回退的版本库的内容。（object）
		后续的选项取决于其他库是否同步进行回退。
		--soft：只回退版本库中的内容。
		--mixed：版本库和暂存区进行回退。默认选项
		--hard：回退所有的内容（工作区、暂存区、版本库） 慎用：注意新开发的会没有（即没上传到版本库中的内容）
	
	回退操作，前面的日志也没了。 
	但是只要知道id，reset就能到指定的提交到版本库中的版本，log也会回到对应的过程。
	
	但是，不知道怎么办呢？
	命令：git reflog  记录本地的每次提交命令，不会随着版本回退而得到修改
		里面存在一部分的id，但是可以利用reset进行版本回退。



git的版本回退速度是非常快的。
	HEAD -> master
		每次回退就是将master里的id改变而已。
	_______________________________________________
	[git]	[git]	[git]...

git版本回退可以回退到当前版本。
	git reset --hard HEAD  回退到当前版本（当前版本就是HEAD指针内存储的master内的内容）
	HEAD^ 上一个版本、^^ 上两个版本... 依次类推
	
	
------------------git的撤销修改
	比如在工作区写了很长时间的代码，越写越写不下去了，觉得自己写的太垃圾了，想恢复到上一个版本。
	
	情况1：未进行add操作
		1.手动撤销 - 容易错误
		2.git命令
		命令：git checkout -- 撤销文件名
			将工作区文件回到最近一次add/commit状态
	情况2：进行了add操作
		使用git回退到当前版本功能 git reset [--mixed | --hard] HEAD 如果使用mixed，还需要对工作区进行一次撤回。
		
	情况3：进行了commit操作
		其他：(版本库) -push ->(远程仓库)    [撤销的目的：就是不影响远程仓库的代码]
		前提条件：commit之后没有进行push操作
			git reset --hard HEAD^ 回退到上一个版本即可。
		
		
------------------对git版本库文件的删除
	1.rm删除工作区的内容  2add提交到暂存区 3commit提交到版本库
	
	命令：git rm 文件名 	对工作区和暂存区删除对应文件
		可以对第一步流程简化两步即可。
	然后在commit即可。
	

	



	