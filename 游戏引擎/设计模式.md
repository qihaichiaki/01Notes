## 面向对象
### 面向对象六大设计原则
* 单一职责原则
> 一个类只能承担一种职责
> 降低耦合性, 增加可读和可维护性, 增加复用性
> 考虑组合模式思想, 不单单限于一种原则

* 开闭原则
> 对扩展开放, 对修改关闭
> 预防性措施，提高灵活性

* 里氏替换原则
> 所有父类出现的地方，均可以使用子类对象替换. 继承的设计体现
> 保证继承体系的正确性, 提高代码的复用性，

* 接口隔离原则
> 拆分为更加细致的接口

* 依赖倒置原则
> 高层次的类不应该依赖低层次的类，应该转嫁到抽象接口之上
> 高低表示着架构中的上层和底层

* 迪米特法则
> 最少知识原则, 一个对象只与其最直接关联的对象进行通信
> 减少链式调用, 减少过多的间接依赖，增强系统稳定性

## 创建型模式
* 创建对象的过程
### 工厂方法模式
1. 抽象产品
2. 具体产品
3. 抽象工厂
4. 具体工厂

> 1. 解耦客户端与具体类依赖（具体产品的代码和使用该产品的客户端内容进行分离）
> 2. 提高系统的可扩展性(引入新的产品无需修改已有的代码)
> 3. 封装复杂对象的创建逻辑（屏蔽对象创建/初始化）
> 4. 遵循开闭原则和单一职责原则
> 5. 提高可维护性(将创建代码的逻辑集中到一处方便后续修改维护)
> 6. 支持更多产品组合


### 抽象工厂方法模式

* 存在多个维度
* 实际上是将工厂方法模式中，一个产品对应一个工厂，弄成了一个工厂可以对应多个产品

### 建造者模式

* 生成器模式，相对于工厂模式，强调的是步骤，而不是结构

1. 产品 最终生成的对象
2. 抽象生成器 约定建造者需要执行的任务内容
3. 具体的生成器 实现建造者的接口
4. 导演/主管 代理调用生成器的建造步骤

> HTTP的请求构造和发起

> 1. 简化构造参数：拆分单个类的构造任务到多个生成器步骤，避免构造函数臃肿
> 2. 灵活组合步骤：通过对构造任务的单一职责拆分，解耦构造过程，灵活的使用组合产出更多变种的产品
> 3. 动态感知构造过程：借助导演，可以在运行时根据建造过程调整各部分任务，暂缓创建或执行递归构造

### 原型模式

* 更优雅的实现对象的拷贝

* 定义一个原型接口，声明了拷贝接口

> 1. 直接使用拷贝构造函数? 
>   静态实现, 不易精确控制拷贝范围
> 2. 类外手动拷贝?
>   不宜访问，并且会产生依赖

### 单例模式

* 对全局变量的优化

> 应用场景
> 1. 资源管理器、场景管理器、配置数据管理器 - > 游戏运行时组件
> 2. 日志管理器、数据库连接池


## 结构型模式
* 如何将对象和类组装为较大的结构，同时保留结构的灵活和高效性

### 适配器模式
* 将不同类的接口转换为客户端希望的另一个接口（不同类的上层功能类似，但是接口不同）

* 目标接口: 客户端需要使用的接口，易用且统一的
* 源接口：不同的对象对应的接口
* 适配器：提供兼容层，避免客户端代码直接依赖不同的设备对象

* 应用场景：
  1. 对接策划表格 -> JSON、XML、CSV、XLS

* 优点:
  1. 符合单一职责和开闭原则
  2. 灵活，十分方便增删已有的适配器

> 对于解析外部数据JSON-XML 推荐cJson和pugixml

### 桥接模式
* 将抽象部分与实现部分分离, 使它们可以独立变化

1. 抽象层
   - 抽象类
   - 扩展抽象类
2. 实现层
   - 实现类接口
   - 具体实现类

### 组合模式
* 将对象组合为树形结构表示"部分-整体"的层次结构
* 适合抽象出灵活通用的游戏框架

* 组件: 定义了所有叶子节点和复合节点的共有的接口
* 叶子结点: 最终执行操作的基础对象或终端元素,不包含子对象
* 复合结点:包含一个或多个子对象的节点,提供对子树的管理接口

> 注意,组合模式不要和ECS搞混
> ECS: Entity Component System
> ECS强调数据驱动,E-标识符 C-独立的数据 S-只有行为,不包含数据
> 组合模式强调的是层次结构和对象组织;ECS可以看作使用数据定义实体的理念,性能优化和行为分离


### 装饰器模式
* 动态的给一个对象添加额外的职责

* 组件: 定义统一接口,如Character类
* 具体组件: 实现基础功能的类
* 装饰器: 继承自组件并持有组件对象
* 具体装饰器: 实际实现装饰功能的装饰器子类

* 应用场景:
  1. 权限管理系统: 控制用户的增删改查
  2. 游戏的输入系统: 实现抖动过滤、坐标转换(比如窗口的放大和缩小)等功能
  3. 数据加密解密：数据传输过程中压缩、加密和协议封装

* 优点
  1. 无需创建新的子类就可以扩展对象行为
  2. 灵活，运行时动态的添加和删除
  3. 单一职责，可以拆分多个装饰器共同完成复杂行为

* 缺点
  1. 删除特定装饰器较为困难
  2. 确保装饰器效果不会因为顺序受影响

### 外观模式
* 为复杂的子系统提供一个简化的接口，来减少客户端与子系统之间的交互的复杂性

* 外观类：提供统一的接口，供客户端去使用
* 子系统：实现具体业务逻辑的类，包含了系统的核心功能


* 优点:
  1. 简明，同时让代码独立于复杂子系统

* 缺点：
  1. 可能会成为与所有类都耦合的上帝对象

### 享元模式
* 通过共享对象来优化大量细粒度对象，优化大量对象的内存占用

* 享元：多个对象所共享的数据或状态
* 享元工厂：对已有的享元缓存池进行管理
* 上下文：每个对象独有的状态

* 应用场景：
  1. 瓦片地图：对单个瓦片对象所使用的纹理、属性进行共享
  2. 粒子系统：对粒子所使用的纹理材质，以及运动规则等数据进行共享

* 缺点：
  1. 更新上下文可能需要牺牲执行速度
  2. 增加结构/维护复杂度


### 代理模式
* 为其他对象提供代理以控制对该对象的访问

* 服务接口：代理类伪装所必须遵守的规则
* 实际服务：实际用于提供业务逻辑的类
* 代理：包含实际服务对象成员，代理完成任务

* 应用场景：
  1. 延迟加载：如大型开放世界游戏中，对地图区块的动态加载
  2. 资源缓存：对音频、模型等繁重资源对象进行代理，避免重复从文件或服务器获取
  3. 权限控制：在多人联机游戏中，对玩家的行为进行校验，判断是否有权限执行
  4. 远程代理：远程过程调用（RPC），将客户端与服务端的通信简化为本地对象调用
  5. 智能代理：为已有的业务添加日志监控性能记录等功能

* 优点：
  1. 可在客户端毫无察觉的情况下控制服务对象
  2. 实现对实际服务对象生命周期的智能管理
  3. 代理类可以在服务对象还未准备好或不存在时正常工作

* 缺点：
  1. 服务没有正常起作用时，调试多了一个维度
  2. 实际服务的响应可能会延迟

## 行为模式
* 如何处理对象间高效沟通或是职责委派，对象可以看作是数据字段和方法行为的合集

### 责任链模式
* 组合一个链表数据结构来组合了动态的处理逻辑

* 请求：记录了责任链上处理者所关心的数据
* 抽象处理者：定义处理请求的接口和设置后继处理者的方法
* 具体处理者：实现具体请求处理逻辑，并决定是否继续传递请求

* 应用场景：
  1. 计算多段伤害
  2. 技能释放时的条件判断
  3. 成就系统的解锁校验
  4. NPC的对话分支

### 命令模式
* 将请求转换为一个包含与请求相关的所有信息的独立对象，可借助它将方法参数化，延迟执行请求或将其放入队列中

* 接收者：具体接受命令的类
* 命令：规定所有具体命令都应该实现的接口
* 具体命令：实现了具体接口功能的命令
* 发送者：用来触发命令调用

* 应用场景：
  1. 用户操作记录与重放，撤销重做功能的实现
  2. 联机游戏中将本地玩家的操作发送到服务器
  3. UI框架和任务调度系统中，对行为任务进行解耦

* 优点：
  1. 解耦发送者和接收者
  2. 参数化命令
  3. 支持撤销重做
  4. 可扩展性极强


### 迭代器模式
* 不暴露底层数据结构的情况下，遍历集合中的所有元素

* 迭代器
* 具体迭代器
* 集合
* 具体集合

* 优点：
  1. 隐藏集合内部复杂的细节
  2. 减少程序中重复的遍历代码
  3. 统一的接口，可以应对不同的和未来无法预知的数据结构
  4. 允许对同一集合实现不同的遍历逻辑

### 中介者模式
* 解决对象之间混乱无序的依赖关系，限制对象彼此之间的直接交互，强迫其通过中介者对象进行合作通信

* 抽象组件：定义业务逻辑类所共有的接口
* 具体组件：实现抽象组件接口包含实际业务代码的类
* 抽象中介者：定义组件交流接口的方法
* 具体中介者：封装多种组件关系持有组件引用

> 代理模式 & 中介者模式
> 使用代理对象对目标对象的直接访问
> 中介者解决的是不同组件之间的通信功能

### 备忘录模式
* 允许在不暴露对象实现细节的情况下，保存/恢复对象之间的状态

> 原型模式 & 备忘录模式
> 备忘录模式的退化，全量->原型

> 命令模式 & 备忘录模式
> 行为的记录 <-> 数据状态

### 观察者模式
* 运行时，动态的检测某个变量的改变

* 主题：约定接口，被观察者
* 观察者：约定接口，常叫订阅者
* 具体主题：允许添加/移除观察者，能够在事件发生后通知现存观察者
* 具体观察者：接收来自主题的通知并做出响应

> 中介者 & 观察者 & 消息总线
> 中介者处理的对象都是对等的
> 观察者侧重于共同关心的一个主题
> 两者结合，可以让中介者充当主题的功能，其他组件充当订阅者的角色
>
> 消息总线
> 容器，允许消息和额外的参数在其上流通，通过回调函数进行流水线式的处理
> 借此，可以实现异步的操作（一个线程消化消息，其他线程发布消息）


### 状态模式
* 可以让一个对象内部状态发生改变时改变其行为

* 状态接口
* 具体状态
* 上下文：持有当前状态的对象，并将请求委托给状态对象

* 优点：
  1. 简化代码：抛弃if..else..或者switch..case..等复杂的条件分支语句
  2. 易于扩展
  3. 单一职责/开闭原则

### 策略模式
* 算法/处理策略封装为对象，方便对上下文环境即插即用

* 策略接口：规定所有策略都需要实现的功能
* 具体策略：实现策略接口，提供具体的算法和行为
* 上下文：持有策略接口的引用，动态的委派给具体的策略执行算法

* 应用场景：
  1. 同类型AI的差异化策略

### 模板方法模式
* 实践面向对象的多态，基类中约定了各个步骤的固定结构

* 抽象类：声明算法步骤方法，确定流程框架
* 具体类：重新各步骤逻辑，但不能修改流程本身

* 缺点：
  1. 灵活程度不足

* 应用场景：
  1. AI行为流程（选择目标、评估环境、做出决策 - 固定的流程骨架）
  2. 游戏关卡生成
  3. 战斗结算流程

### 访问者模式
* 可以将算法与它的作用对象隔离开（原属于成员方法的部分分离到类外进行独立实现）

* 抽象访问者：约定访问具体元素的接口
* 具体访问者：实现接口逻辑，定义对具体元素的实际操作
* 抽象元素类：约定允许访问者访问的接口
* 具体元素类：实现接收访问的具体逻辑，调用访问者对应方法

* 优点：
  1. 复合开闭原则
  2. 将处理逻辑集中放置，提高可读性降低维护成本

* 缺点：
  1. 破坏封装性
  2. 若元素变化则需要修改访问者，导致维护成本提高

* 应用场景：
  1. 道具/技能的效果 - 对周围环境产生不同的效果
  2. 物理引擎的处理：刚体/触发器的属性可以和碰撞处理算法分离

### 解释器模式
* 定义语言的文法，并且为该文法定义解释执行的方法，来将输入解释为可执行的行为（py、lua、js）

* 应用场景：
  1. 游戏开发：使用脚本来提高开发和调试的效率（如果和游戏引擎使用相同的语言编写游戏逻辑(C++),调试时会出现恐怖的编译时间，接入脚本的设计后，无需更新游戏体积较大的固化程序框架和资源，只是替换轻量的脚本文件，可以实现完全不同的游戏逻辑）
  2. 领域特定语言(DSL)：数据库查询语句
  3. 规则引擎：正则表达式

* 优点：
  1. 灵活度高：用户可以任意扩展自己的逻辑
  2. 易于扩展：解释器本身与表达式完全解耦，可以独立升级提供新的特性

* 缺点：
  1. 性能欠佳：复杂表达式或者大规模语法树进行分析时导致性能下降
  2. 代码复杂：实现一套完全的解释器是一个十分有挑战性的任务

## 面试/热点



### ECS架构
* Entity - 对象唯一标识
* Component - 对象数据
* System - 对象行为

* 优点：
  1. 数据驱动与高性能
  2. 低耦合和灵活扩展
  3. 易于管理大量对象

* 缺点：
  1. 学习曲线较陡峭
  2. 调试较为复杂
  3. 架构设计成本高

* 开源项目：EnTT/Flecs