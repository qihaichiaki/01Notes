写代码时遵循一些模板和思想：前人总结出来的解决方案。

有些经常遇到的问题早被人们研究透了，于是我们总结出一些用来解决此类问题的最优方法 - 设计模式。

--1.单例模式--
-最简单、最常用、非常被滥用的设计模式。

1.始终允许有一个该类的实例。
2.对该实例存在一个全局的访问点。
-优雅的创建通用的单例类即可，然后需要单例的时候继承即可。

-补充知识：
	a??b => a!=null?a:b;a不为空返回a否则返回b
好用的基础单例类：
public class Singleton<T> where T: class, new()
{
	protected Singleton();
	privte static T _inst = null;
	public static T instance => _inst ?? (_inst = new T());
	public static void Clear() => _inst = null;
}

优点：1.单一性：始终只会有一个实例。方便管理
2.便利性，全局的访问点使我们可以很方便的从任何地方访问单例。
3.懒：需要的时候实例化一次（懒人模式）

缺点：1.全局性：增加耦合度，降低可读性，提高出错性。很多时候我们可以使用static字段与方法代替单例。
2.依赖性：过度使用，出错会导致整个系统崩溃。
使用单例前先想想有没有其他更好的实现方式？


--2.指令模式--
ctrl Z的灵魂所在。
将我们的每一个操作抽象为一个指令，给每个指令一个撤销的操作。
（抽象类类似于接口：abstract，方法最前面也要加上abstract，只不过子类的继承的实现方法是重写）
public interface ICommand
{
	void Execute();  // 执行指令
	void Undo();  // 撤销指令
}
记录之前完成过的指令就可以一步一步往后面撤销了。
核心组成部分：
	1.指令接口
	2.指令类
	3.调用者：存储、调用指令（Manger）
	4.接收者：实现一个指令
	5.使用者：创建指令并且执行它们。

优缺点：
	开发软件工具时常用。（关卡编辑器）
	优点：调用者与执行者解耦，增加模块化。完美实现撤回功能以及其他指令相关的操作。
	缺点：每个指令都是单独的一个类，体量大了之后不适合管理。
-不通用，对特定领域有出类拔萃的效果。（撤回、时间倒流）


--3.工厂模式--
顾名思义：用于生产物品的工厂，将类的实例化过程包装起来，使使用者方便可控的获得一个类的实例。（类的实例化包装起来，根据不同类型返回一个子类对象实例即可）
-抽象工厂模式：
	将工厂本身给抽象出来-作为接口实现，真正的工厂类继承工厂接口。
-差别：工厂模式生产一个单一的物体（返回值都是一个基类对象），抽象工厂模式生产工厂的，这样就可以创建一系列有联系的物体。


--4.观察者模式--
存在观察者和通知者两方，通知者发生变化时通知所有观察者作出反应。C#中的委托与事件系统就是此模式的体现。

unity事件系统也是：button添加响应事件 - 添加了许多观察者，点击时观察者触发。

--5.策略模式--
程序运行时根据情况选择一种算法来完成任务。





-------------对象池
Unity实时创建和摧毁-很费性能的事情。
对于简单的可复用的物体可以考虑enable/disable -对性能的影响小很多。
-可以采用对象池思想实现这样的功能。
使用一个对象时先看对应池子里存不存在空闲的实例，有直接用，否则创建。摧毁时并不直接摧毁，只需标记为空闲即可，不直接销毁它。








------------Ecs
Entity、Component、System模式
游戏、引擎开发中广泛使用的设计模式。
Entity实体：GameObject类似，有ID的物体，有且只有一系列的component;
component和unity的不同，ECS只不过是一些数据结构，提供了物体执行逻辑所需数据，
System真正完成物体逻辑的地方，system会在所有特定的component的entity上执行操作。
unity不是完全是一个ECS模式的引擎，unity没有System一说，数据和逻辑都放在了component内。



---与熟知的面向对象编程不同，ECS是面向数据编程。注重于对数据本身进行操作，而非把数据放进物体里再对物体进行操作。
好处：1.连续内存布局：相同类型组件连续内存处处，更快访问和迭代数据。2.更少的不必要数据。实体只拥有与其需求相关的组件。3.并行性，系统只关心组件中的数据，更容易设计安全的多线程代码。




-练习：
1.不使用Unity/C#的事件系统，尝试自己编写一个观察者模式。
2.MonoSingleton继承自MonoBehaviour的单例类。
	.区别，如果当前_inst为空，不是返回new了，因为Awake一开始必定创建了-
3.指令模式实现：w玩家向前，s向后，z撤回上一步移动。
4.备忘录模式-很简单且常用的设计模式，按下R使玩家回到初始位置、旋转、初始大小。
{
	发起人
	备忘录角色 Memento
	-备忘录管理员 Caretaker
}




