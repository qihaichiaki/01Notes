骨骼动画
调整骨骼控制物体外形的技术。

父骨头、子骨头。父动，子也会跟着一起动。-层级结构。

2D开发中：骨骼动画、帧动画（每段时间内每帧替换一张图片，让物体看起来正在动一样。）
帧动画：单独定制、及其可控。缺点占用空间大，且帧率有限（无法在两个关键帧之间插值）
骨骼动画实质上是一种程序化动画，最大的优先是实时性，占用空间会很小。

3D骨骼动画（直接控制物体Transform本质没有区别）骨骼动画是间接的控制物体的形态。
FK - IK


1->2->3->4->end
-------------------FK：正向动力学
例子：1、2、3、4推出end的状态
	1.Joint关节 骨骼头部，控制旋转
	2.Links连结 骨骼尾部
	3.End-Effector末端器 整条骨骼的尾部
	4.Kinematic Chain动力学链 一整条彼此相连的骨骼。
	
	递进的过程
	b0 -> b1
	b1的头部位置 = b0的尾部位置 = b0头部+b0方向 * 长度
	b1尾部位置...
	程序实现FK末端位置的计算（）

制作2D骨骼动画（FK）
	骨骼和外形建立联系 - 蒙皮
	unity的sprite Editor提供了此功能，可使用ＰＳＢ类型文件导入unity。
		pose 预览
		Bones 骨骼相关
		Geometry 几何处理-顶点
		weights 骨骼对每个顶点的影响程度
	
	步骤：
		1.Auto Gemetry 自动生成多边形 （右下方的Generate For All Visible使其生成的更加自然一点）
		2.Greate Bone（右键取消创建）
		3.Auto Weights 自动生成骨骼对几何权重（对多边形顶点的影响程度）
			右下角Associate Bones选中，点击Generate All 查看分配的几何权重（每个骨骼对应颜色查看其骨骼影响范围）
		4.去掉不受对应骨骼影响的图层-Bone Influence - 
		
		weight Brush 选择一个图的骨骼权重，涂到对应几何上。


-------------------IK：逆向动力学
例子：根据end的状态，逆向推出4、3、2、1的状态
	IK - 生活中经常存在，我们人脑的处理各种运动也是一种IK。
	Target 让物体尝试让End Effector到达的位置。
	-IK可能存在多个解，我们通常需要找到最优解。

-解法：数值解（数值）、解析解（公式、表达式）
	2D IK数值解法以下解法：
	Limb Solver
	Cyclic Coordinate Descent （CCD） Solver
	Forwar And Backward Reaching IK （FABRIK）Solver
	
	Limb Solver2D是IK算法最简单的之一。用于解长度为2的IK系统。
ed:
*target 
               ^
	|
	|
	root
		计算步骤：
			1.计算从根节点到Target的距离d，整个骨骼链的目标长度
			2.d大于两根骨骼的长度总和s，那么我们无法到达Target，这种情况下，对着Target的方向就是最优解。
			3.d小于s，那么一定可以到达。计算出根结点到Target这条线与根骨骼本身的夹角（使用宇轩定理）和两根骨骼之间的夹角。接着我们更具这两个夹角计算出使得End Effector 到达Target的一种方法。
		限制：
			1.两根骨骼之间夹角只能在0~180度（构成三角形），只能向一个方向弯曲。
			2.只支持长度2IK系统
			3.不可控，无法加旋转角度范围限制。第二根骨骼只能相对于第一个骨骼往右转。
		自然

		
	CCD Solver 2D
		高级，通用的解法，迭代、逐步逼近的方法获得最优解的近似。
		步骤：
			1.初始化 从end开始
			2.旋转 从end一步步到根骨骼，计算每一个骨骼到end和它到target的夹角，旋转骨骼以最小化这个夹角。
			3.检查 如果end effector和Target以及足够近了，结束算法。
			4.迭代 没有，在进行迭代，如果迭代了x编没有通过检查，算法停止。

	b2 ——b1——b0 end  
				*target
		中规中矩的方法。
		缺点：不能总能找到自然的解法。（自然：看起来符合生活中的现象）

	
	FABRIK Solver 2D
		迭代，支持任意长度的IK解法。核心算法：由两头向中间进行计算。
		步骤：
			1.初始化：算法从根骨骼开始
			2.前向计算：从根->end，对每个骨骼将其放在上一个骨骼和Target的连线方向上（隔开一段距离），全部执行结束后，所有的骨骼会被拉向Target，且End一定在Target的方向上。
			3.反向计算：从end到根骨骼，步骤同上。全部执行完毕后所有骨骼会被拉向根骨骼，end也还在Target上。
			4.迭代：重复2、3，知道end 与Target距离够近或者达到迭代数量。
		

		相对于Limb 和 CCD，这是一种更加成熟的做法。可以找到较为自然的解法，虽然复杂但是迭代次数比ccd小。

	-上述三种算法Unity均提供了。
		在Package Manager - 增加2D package

--unity控制IK：
	添加IK Manager2D组件  在一个空物体上
	将end、target 的的对应transfrom付给即可。
	chain Length控制多少顶点进行设定。（end也需要算上）
	迭代次数越多更精确，相对的性能也会变多。


课后练习。
	1.理解CCD 与FABRIK算法，写出它们的伪代码
	2.列举五个游戏中常见通过IK实现的功能：
		1.角色上斜坡让脚贴合地面的功能
	3.为一个火柴人（或者任意人形）图片制作待机与走路的骨骼动画。

